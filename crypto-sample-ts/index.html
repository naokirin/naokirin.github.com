<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>暗号技術サンプル - Crypto Sample TS</title>
  <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial,
        sans-serif;
      line-height: 1.6;
      color: #333;
      background-color: #f5f5f5;
      padding: 20px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      padding: 30px;
    }

    h1 {
      margin-bottom: 30px;
      color: #2c3e50;
      border-bottom: 3px solid #3498db;
      padding-bottom: 10px;
    }

    .section {
      margin-bottom: 30px;
      padding: 20px;
      background: #f9f9f9;
      border-radius: 6px;
      border-left: 4px solid #3498db;
    }

    .section h2 {
      margin-bottom: 15px;
      color: #2c3e50;
      font-size: 1.3em;
    }

    .section h3 {
      margin-top: 20px;
      margin-bottom: 10px;
      color: #34495e;
      font-size: 1.1em;
    }

    label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
      color: #2c3e50;
    }

    select,
    input[type="text"],
    textarea {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
      font-family: monospace;
    }

    select {
      background: white;
      cursor: pointer;
    }

    textarea {
      min-height: 100px;
      resize: vertical;
      font-family: "Courier New", monospace;
    }

    button {
      background: #3498db;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: background 0.3s;
      margin-right: 10px;
      margin-top: 10px;
    }

    button:hover {
      background: #2980b9;
    }

    button:disabled {
      background: #bdc3c7;
      cursor: not-allowed;
    }

    .output {
      background: #2c3e50;
      color: #ecf0f1;
      padding: 15px;
      border-radius: 4px;
      font-family: "Courier New", monospace;
      font-size: 13px;
      word-break: break-all;
      margin-top: 10px;
      overflow-x: auto;
    }

    .error {
      background: #e74c3c;
      color: white;
      padding: 15px;
      border-radius: 4px;
      margin-top: 10px;
    }

    .info {
      background: #3498db;
      color: white;
      padding: 10px;
      border-radius: 4px;
      margin-bottom: 15px;
      font-size: 14px;
    }

    .param-group {
      margin-bottom: 15px;
    }

    .param-label {
      font-size: 12px;
      color: #7f8c8d;
      margin-top: 5px;
    }

    .mode-tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      border-bottom: 2px solid #bdc3c7;
    }

    .mode-tab {
      padding: 10px 20px;
      background: #ecf0f1;
      border: none;
      border-bottom: 3px solid transparent;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      color: #7f8c8d;
      transition: all 0.3s;
    }

    .mode-tab:hover {
      background: #d5dbdb;
      color: #2c3e50;
    }

    .mode-tab.active {
      background: white;
      color: #3498db;
      border-bottom-color: #3498db;
    }

    .step {
      margin-bottom: 20px;
      padding: 15px;
      background: white;
      border-radius: 4px;
      border: 1px solid #e0e0e0;
    }

    .step-title {
      font-weight: 600;
      color: #2c3e50;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
    }

    .step-number {
      display: inline-block;
      width: 24px;
      height: 24px;
      background: #3498db;
      color: white;
      border-radius: 50%;
      text-align: center;
      line-height: 24px;
      font-size: 12px;
      margin-right: 10px;
    }

    .detail-toggle {
      background: #95a5a6;
      font-size: 12px;
      padding: 6px 12px;
      margin-left: 10px;
    }

    .detail-toggle:hover {
      background: #7f8c8d;
    }

    .detail-section {
      margin-top: 15px;
      padding: 15px;
      background: #ecf0f1;
      border-radius: 4px;
      border-left: 3px solid #3498db;
    }

    .detail-section h4 {
      margin-bottom: 10px;
      color: #2c3e50;
      font-size: 14px;
    }

    .data-flow {
      display: flex;
      align-items: center;
      margin: 10px 0;
      flex-wrap: wrap;
      gap: 10px;
    }

    .data-box {
      padding: 10px;
      background: white;
      border: 1px solid #bdc3c7;
      border-radius: 4px;
      flex: 1;
      min-width: 200px;
    }

    .data-box-label {
      font-size: 11px;
      color: #7f8c8d;
      margin-bottom: 5px;
      text-transform: uppercase;
      font-weight: 600;
    }

    .data-box-content {
      font-family: "Courier New", monospace;
      font-size: 12px;
      word-break: break-all;
    }

    .arrow {
      font-size: 20px;
      color: #3498db;
      font-weight: bold;
    }

    .bytes-detail {
      margin-top: 10px;
    }

    .bytes-detail table {
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
      background: white;
    }

    .bytes-detail th,
    .bytes-detail td {
      padding: 5px;
      border: 1px solid #bdc3c7;
      text-align: left;
    }

    .bytes-detail th {
      background: #34495e;
      color: white;
      font-weight: 600;
    }

    .bytes-detail td {
      font-family: "Courier New", monospace;
    }
  </style>
  <script type="module" crossorigin src="./assets/index-BJN8_nOb.js"></script>
</head>

<body>
  <div class="container" x-data="window.cryptoApp ? window.cryptoApp() : { selectedCrypto: '' }" x-init="if (!window.cryptoApp) { const checkApp = setInterval(() => { if (window.cryptoApp) { Object.assign($data, window.cryptoApp()); clearInterval(checkApp); } }, 50); }">
    <h1>🔐 暗号技術サンプルデモ</h1>

    <div class="section">
      <h2>暗号技術の選択</h2>
      <label for="crypto-select">暗号技術を選択してください:</label>
      <select id="crypto-select" x-model="selectedCrypto" @change="resetState()">
        <option value="">選択してください</option>
        <optgroup label="対称鍵暗号">
          <option value="aes">AES (Advanced Encryption Standard)</option>
          <option value="chacha20">ChaCha20</option>
        </optgroup>
        <optgroup label="非対称鍵暗号">
          <option value="rsa">RSA (Rivest-Shamir-Adleman)</option>
          <option value="ecc">ECC (Elliptic Curve Cryptography)</option>
          <option value="ibe">IBE (Identity-Based Encryption)</option>
          <option value="abe">ABE (Attribute-Based Encryption)</option>
        </optgroup>
        <optgroup label="ハッシュ関数">
          <option value="hash-sha256">SHA-256 (256-bit)</option>
          <option value="hash-sha512">SHA-512 (512-bit)</option>
          <option value="hash-sha3-256">SHA-3-256 (256-bit)</option>
          <option value="hash-blake2b">BLAKE2b (512-bit)</option>
          <option value="hash-blake3">BLAKE3 (256-bit)</option>
          <option value="hash-compare">全アルゴリズム比較計算</option>
        </optgroup>
        <optgroup label="MAC (Message Authentication Code)">
          <option value="poly1305">Poly1305</option>
          <option value="siphash">SipHash (64-bit MAC)</option>
        </optgroup>
        <optgroup label="耐量子暗号 (Post-Quantum Cryptography)">
          <option value="kyber">CRYSTALS-Kyber (ML-KEM)</option>
          <option value="dilithium">CRYSTALS-Dilithium (ML-DSA)</option>
          <option value="falcon">FALCON (FN-DSA)</option>
        </optgroup>
        <optgroup label="検索可能暗号 (Searchable Encryption)">
          <option value="sse">SSE (Searchable Symmetric Encryption)</option>
        </optgroup>
      </select>
    </div>

    <template x-if="selectedCrypto && selectedCrypto.startsWith('aes')">
      <div>
        <div class="section">
          <h2>AES-GCM の動作</h2>
          <div class="info">
            <strong>初期化パラメータ:</strong><br />
            鍵長: 256ビット (32バイト)<br />
            IV長: 96ビット (12バイト)<br />
            認証タグ長: 128ビット (16バイト)
          </div>

          <div class="step">
            <div class="step-title">
              <span class="step-number">1</span>
              鍵生成
              <button class="detail-toggle"
                @click="aesState.showDetails.keyGeneration = !aesState.showDetails.keyGeneration" x-show="aesState.key">
                <span x-show="!aesState.showDetails.keyGeneration">詳細を表示</span>
                <span x-show="aesState.showDetails.keyGeneration">詳細を隠す</span>
              </button>
            </div>
            <button @click="generateAESKey()">鍵を生成</button>
            <div x-show="aesState.key" class="output" x-text="formatBytes(aesState.key)"></div>
            <div x-show="aesState.showDetails.keyGeneration && aesState.key" class="detail-section">
              <h4>🔍 鍵生成の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 暗号学的に安全な乱数生成</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    CSPRNG（暗号学的擬似乱数生成器）を使用
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. 256ビット（32バイト）の鍵を生成</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    各バイトは0x00～0xFFのランダムな値
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. 生成された鍵</div>
                  <div class="data-box-content" x-text="formatBytesReadable(aesState.key)"></div>
                  <div class="param-label">
                    長さ: <span x-text="aesState.key?.length || 0"></span> バイト（<span
                      x-text="(aesState.key?.length || 0) * 8"></span>
                    ビット）
                  </div>
                </div>
              </div>
              <div class="bytes-detail" x-show="aesState.key">
                <h4>鍵のバイト詳細</h4>
                <table>
                  <thead>
                    <tr>
                      <th>位置</th>
                      <th>16進数</th>
                      <th>10進数</th>
                      <th>2進数（8ビット）</th>
                    </tr>
                  </thead>
                  <tbody>
                    <template x-for="(byte, index) in Array.from(aesState.key || [])" :key="index">
                      <tr>
                        <td x-text="index"></td>
                        <td x-text="byte.toString(16).padStart(2, '0').toUpperCase()"></td>
                        <td x-text="byte"></td>
                        <td x-text="byte.toString(2).padStart(8, '0')"></td>
                      </tr>
                    </template>
                  </tbody>
                </table>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. 暗号学的に安全な乱数生成器（CSPRNG）を使用して、予測不可能なランダムなバイト列を生成します。<br />
                2. AES-256では256ビット（32バイト）の鍵を使用します。この鍵長は、現在の標準的なセキュリティレベルを提供します。<br />
                3. 生成された鍵は秘密情報として扱い、安全に保管する必要があります。同じ鍵を使用することで、暗号化と復号化が可能になります。<br />
                4. 鍵は毎回ランダムに生成されるため、同じ平文でも異なる暗号文が生成されます（IVもランダムに生成されるため）。
              </div>
            </div>
          </div>

          <div class="step">
            <div class="step-title">
              <span class="step-number">2</span>
              暗号化
              <button class="detail-toggle" @click="aesState.showDetails.encryption = !aesState.showDetails.encryption"
                x-show="aesState.ciphertext">
                <span x-show="!aesState.showDetails.encryption">詳細を表示</span>
                <span x-show="aesState.showDetails.encryption">詳細を隠す</span>
              </button>
            </div>
            <div class="param-group">
              <label>平文:</label>
              <textarea x-model="aesState.plaintext" placeholder="暗号化するテキストを入力"></textarea>
            </div>
            <button @click="encryptAES()" :disabled="!aesState.key || !aesState.plaintext">
              暗号化
            </button>
            <div x-show="aesState.ciphertext" class="output">
              <strong>暗号文:</strong><br />
              <span x-text="formatBytes(aesState.ciphertext)"></span><br /><br />
              <strong>IV:</strong><br />
              <span x-text="formatBytes(aesState.iv)"></span><br /><br />
              <strong>認証タグ:</strong><br />
              <span x-text="formatBytes(aesState.authTag)"></span>
            </div>
            <div x-show="aesState.showDetails.encryption && aesState.ciphertext" class="detail-section">
              <h4>🔍 暗号化の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 入力（文字列）</div>
                  <div class="data-box-content" x-text="aesState.plaintext || '(空)'"></div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. バイト配列に変換</div>
                  <div class="data-box-content" x-text="formatBytesReadable(aesState.plaintextBytes)"></div>
                  <div class="param-label">長さ: <span x-text="aesState.plaintextBytes?.length || 0"></span> バイト</div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. AES-GCMで暗号化</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    鍵 + IV + 平文 → 暗号文 + 認証タグ
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">4. 出力（暗号文）</div>
                  <div class="data-box-content" x-text="formatBytesReadable(aesState.ciphertext)"></div>
                  <div class="param-label">長さ: <span x-text="aesState.ciphertext?.length || 0"></span> バイト</div>
                </div>
              </div>
              <div class="bytes-detail" x-show="aesState.plaintextBytes">
                <h4>平文のバイト詳細</h4>
                <table>
                  <thead>
                    <tr>
                      <th>位置</th>
                      <th>16進数</th>
                      <th>10進数</th>
                      <th>ASCII</th>
                      <th>文字</th>
                    </tr>
                  </thead>
                  <tbody>
                    <template x-for="(byte, index) in Array.from(aesState.plaintextBytes || [])" :key="index">
                      <tr>
                        <td x-text="index"></td>
                        <td x-text="byte.toString(16).padStart(2, '0')"></td>
                        <td x-text="byte"></td>
                        <td x-text="byte >= 32 && byte <= 126 ? String.fromCharCode(byte) : '.'"></td>
                        <td x-text="byte >= 32 && byte <= 126 ? String.fromCharCode(byte) : '(制御文字)'"></td>
                      </tr>
                    </template>
                  </tbody>
                </table>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. 平文をUTF-8エンコーディングでバイト配列に変換します。<br />
                2. AES-GCMモードで暗号化します。GCMは認証付き暗号（AEAD）で、暗号化と同時に認証タグを生成します。<br />
                3. IV（初期化ベクトル）はランダムに生成され、同じ平文でも異なる暗号文になります。<br />
                4. 認証タグはデータの完全性を保証するために使用されます。
              </div>
            </div>
          </div>

          <div class="step">
            <div class="step-title">
              <span class="step-number">3</span>
              復号化
              <button class="detail-toggle" @click="aesState.showDetails.decryption = !aesState.showDetails.decryption"
                x-show="aesState.decrypted">
                <span x-show="!aesState.showDetails.decryption">詳細を表示</span>
                <span x-show="aesState.showDetails.decryption">詳細を隠す</span>
              </button>
            </div>
            <button @click="decryptAES()" :disabled="!aesState.ciphertext">復号化</button>
            <div x-show="aesState.decrypted" class="output" x-text="aesState.decrypted"></div>
            <div x-show="aesState.error" class="error" x-text="aesState.error"></div>
            <div x-show="aesState.showDetails.decryption && aesState.decrypted" class="detail-section">
              <h4>🔍 復号化の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 入力（暗号文）</div>
                  <div class="data-box-content" x-text="formatBytesReadable(aesState.ciphertext)"></div>
                  <div class="param-label">長さ: <span x-text="aesState.ciphertext?.length || 0"></span> バイト</div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. 認証タグで検証</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    暗号文 + IV + 認証タグ → 認証チェック
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. AES-GCMで復号</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    鍵 + IV + 暗号文 → 平文バイト配列
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">4. バイト配列を文字列に変換</div>
                  <div class="data-box-content" x-text="formatBytesReadable(aesState.decryptedBytes)"></div>
                  <div class="param-label">長さ: <span x-text="aesState.decryptedBytes?.length || 0"></span> バイト</div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">5. 出力（文字列）</div>
                  <div class="data-box-content" x-text="aesState.decrypted"></div>
                </div>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. 暗号文、IV、認証タグを使用して復号化します。<br />
                2. 認証タグを検証し、データが改ざんされていないことを確認します。<br />
                3. 認証が成功した場合のみ、暗号文を平文に復号します。<br />
                4. 復号されたバイト配列をUTF-8デコードして文字列に変換します。
              </div>
            </div>
          </div>
        </div>
      </div>
    </template>

    <template x-if="selectedCrypto === 'chacha20'">
      <div>
        <div class="section">
          <h2>XChaCha20-Poly1305 の動作</h2>
          <div class="info">
            <strong>初期化パラメータ:</strong><br />
            鍵長: 256ビット (32バイト)<br />
            ノンス長: 192ビット (24バイト)<br />
            認証タグ長: 128ビット (16バイト)
          </div>

          <div class="step">
            <div class="step-title">
              <span class="step-number">1</span>
              鍵生成
              <button class="detail-toggle"
                @click="chacha20State.showDetails.keyGeneration = !chacha20State.showDetails.keyGeneration"
                x-show="chacha20State.key">
                <span x-show="!chacha20State.showDetails.keyGeneration">詳細を表示</span>
                <span x-show="chacha20State.showDetails.keyGeneration">詳細を隠す</span>
              </button>
            </div>
            <button @click="generateChaCha20Key()">鍵を生成</button>
            <div x-show="chacha20State.key" class="output" x-text="formatBytes(chacha20State.key)"></div>
            <div x-show="chacha20State.showDetails.keyGeneration && chacha20State.key" class="detail-section">
              <h4>🔍 鍵生成の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 暗号学的に安全な乱数生成</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    CSPRNG（暗号学的擬似乱数生成器）を使用
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. 256ビット（32バイト）の鍵を生成</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    各バイトは0x00～0xFFのランダムな値
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. 生成された鍵</div>
                  <div class="data-box-content" x-text="formatBytesReadable(chacha20State.key)"></div>
                  <div class="param-label">
                    長さ: <span x-text="chacha20State.key?.length || 0"></span> バイト（<span
                      x-text="(chacha20State.key?.length || 0) * 8"></span>
                    ビット）
                  </div>
                </div>
              </div>
              <div class="bytes-detail" x-show="chacha20State.key">
                <h4>鍵のバイト詳細</h4>
                <table>
                  <thead>
                    <tr>
                      <th>位置</th>
                      <th>16進数</th>
                      <th>10進数</th>
                      <th>2進数（8ビット）</th>
                    </tr>
                  </thead>
                  <tbody>
                    <template x-for="(byte, index) in Array.from(chacha20State.key || [])" :key="index">
                      <tr>
                        <td x-text="index"></td>
                        <td x-text="byte.toString(16).padStart(2, '0').toUpperCase()"></td>
                        <td x-text="byte"></td>
                        <td x-text="byte.toString(2).padStart(8, '0')"></td>
                      </tr>
                    </template>
                  </tbody>
                </table>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. 暗号学的に安全な乱数生成器（CSPRNG）を使用して、予測不可能なランダムなバイト列を生成します。<br />
                2. XChaCha20-Poly1305では256ビット（32バイト）の鍵を使用します。この鍵長は、高いセキュリティレベルを提供します。<br />
                3. 生成された鍵は秘密情報として扱い、安全に保管する必要があります。同じ鍵を使用することで、暗号化と復号化が可能になります。<br />
                4. 鍵は毎回ランダムに生成されるため、同じ平文でも異なる暗号文が生成されます（ノンスもランダムに生成されるため）。
              </div>
            </div>
          </div>

          <div class="step">
            <div class="step-title">
              <span class="step-number">2</span>
              暗号化
              <button class="detail-toggle"
                @click="chacha20State.showDetails.encryption = !chacha20State.showDetails.encryption"
                x-show="chacha20State.ciphertext">
                <span x-show="!chacha20State.showDetails.encryption">詳細を表示</span>
                <span x-show="chacha20State.showDetails.encryption">詳細を隠す</span>
              </button>
            </div>
            <div class="param-group">
              <label>平文:</label>
              <textarea x-model="chacha20State.plaintext" placeholder="暗号化するテキストを入力"></textarea>
            </div>
            <button @click="encryptChaCha20()" :disabled="!chacha20State.key || !chacha20State.plaintext">
              暗号化
            </button>
            <div x-show="chacha20State.ciphertext" class="output">
              <strong>暗号文:</strong><br />
              <span x-text="formatBytes(chacha20State.ciphertext)"></span><br /><br />
              <strong>ノンス:</strong><br />
              <span x-text="formatBytes(chacha20State.nonce)"></span><br /><br />
              <strong>認証タグ:</strong><br />
              <span x-text="formatBytes(chacha20State.authTag)"></span>
            </div>
            <div x-show="chacha20State.showDetails.encryption && chacha20State.ciphertext" class="detail-section">
              <h4>🔍 暗号化の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 入力（文字列）</div>
                  <div class="data-box-content" x-text="chacha20State.plaintext || '(空)'"></div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. バイト配列に変換</div>
                  <div class="data-box-content" x-text="formatBytesReadable(chacha20State.plaintextBytes)"></div>
                  <div class="param-label">長さ: <span x-text="chacha20State.plaintextBytes?.length || 0"></span> バイト
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. XChaCha20-Poly1305で暗号化</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    鍵 + ノンス + 平文 → 暗号文 + 認証タグ
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">4. 出力（暗号文）</div>
                  <div class="data-box-content" x-text="formatBytesReadable(chacha20State.ciphertext)"></div>
                  <div class="param-label">長さ: <span x-text="chacha20State.ciphertext?.length || 0"></span> バイト</div>
                </div>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. 平文をUTF-8エンコーディングでバイト配列に変換します。<br />
                2. XChaCha20-Poly1305（認証付き暗号）で暗号化します。ChaCha20はストリーム暗号で、Poly1305は認証タグを生成します。<br />
                3. ノンス（nonce）はランダムに生成され、同じ平文でも異なる暗号文になります。<br />
                4. 認証タグはデータの完全性を保証するために使用されます。
              </div>
            </div>
          </div>

          <div class="step">
            <div class="step-title">
              <span class="step-number">3</span>
              復号化
              <button class="detail-toggle"
                @click="chacha20State.showDetails.decryption = !chacha20State.showDetails.decryption"
                x-show="chacha20State.decrypted">
                <span x-show="!chacha20State.showDetails.decryption">詳細を表示</span>
                <span x-show="chacha20State.showDetails.decryption">詳細を隠す</span>
              </button>
            </div>
            <button @click="decryptChaCha20()" :disabled="!chacha20State.ciphertext">
              復号化
            </button>
            <div x-show="chacha20State.decrypted" class="output" x-text="chacha20State.decrypted"></div>
            <div x-show="chacha20State.error" class="error" x-text="chacha20State.error"></div>
            <div x-show="chacha20State.showDetails.decryption && chacha20State.decrypted" class="detail-section">
              <h4>🔍 復号化の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 入力（暗号文）</div>
                  <div class="data-box-content" x-text="formatBytesReadable(chacha20State.ciphertext)"></div>
                  <div class="param-label">長さ: <span x-text="chacha20State.ciphertext?.length || 0"></span> バイト</div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. 認証タグで検証</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    暗号文 + ノンス + 認証タグ → 認証チェック
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. XChaCha20-Poly1305で復号</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    鍵 + ノンス + 暗号文 → 平文バイト配列
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">4. バイト配列を文字列に変換</div>
                  <div class="data-box-content" x-text="formatBytesReadable(chacha20State.decryptedBytes)"></div>
                  <div class="param-label">長さ: <span x-text="chacha20State.decryptedBytes?.length || 0"></span> バイト
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">5. 出力（文字列）</div>
                  <div class="data-box-content" x-text="chacha20State.decrypted"></div>
                </div>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. 暗号文、ノンス、認証タグを使用して復号化します。<br />
                2. Poly1305で認証タグを検証し、データが改ざんされていないことを確認します。<br />
                3. 認証が成功した場合のみ、ChaCha20で暗号文を平文に復号します。<br />
                4. 復号されたバイト配列をUTF-8デコードして文字列に変換します。
              </div>
            </div>
          </div>
        </div>
      </div>
    </template>

    <template x-if="selectedCrypto === 'poly1305'">
      <div>
        <div class="section">
          <h2>Poly1305 (MAC) の動作</h2>
          <div class="info">
            <strong>初期化パラメータ:</strong><br />
            鍵長: 256ビット (32バイト)<br />
            認証タグ長: 128ビット (16バイト)
          </div>

          <div class="step">
            <div class="step-title">
              <span class="step-number">1</span>
              鍵生成
              <button class="detail-toggle"
                @click="poly1305State.showDetails.keyGeneration = !poly1305State.showDetails.keyGeneration"
                x-show="poly1305State.key">
                <span x-show="!poly1305State.showDetails.keyGeneration">詳細を表示</span>
                <span x-show="poly1305State.showDetails.keyGeneration">詳細を隠す</span>
              </button>
            </div>
            <button @click="generatePoly1305Key()">鍵を生成</button>
            <div x-show="poly1305State.key" class="output" x-text="formatBytes(poly1305State.key)"></div>
            <div x-show="poly1305State.showDetails.keyGeneration && poly1305State.key" class="detail-section">
              <h4>🔍 鍵生成の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 暗号学的に安全な乱数生成</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    CSPRNG（暗号学的擬似乱数生成器）を使用
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. 256ビット（32バイト）の鍵を生成</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    各バイトは0x00～0xFFのランダムな値
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. 生成された鍵</div>
                  <div class="data-box-content" x-text="formatBytesReadable(poly1305State.key)"></div>
                  <div class="param-label">
                    長さ: <span x-text="poly1305State.key?.length || 0"></span> バイト（<span
                      x-text="(poly1305State.key?.length || 0) * 8"></span>
                    ビット）
                  </div>
                </div>
              </div>
              <div class="bytes-detail" x-show="poly1305State.key">
                <h4>鍵のバイト詳細</h4>
                <table>
                  <thead>
                    <tr>
                      <th>位置</th>
                      <th>16進数</th>
                      <th>10進数</th>
                      <th>2進数（8ビット）</th>
                    </tr>
                  </thead>
                  <tbody>
                    <template x-for="(byte, index) in Array.from(poly1305State.key || [])" :key="index">
                      <tr>
                        <td x-text="index"></td>
                        <td x-text="byte.toString(16).padStart(2, '0').toUpperCase()"></td>
                        <td x-text="byte"></td>
                        <td x-text="byte.toString(2).padStart(8, '0')"></td>
                      </tr>
                    </template>
                  </tbody>
                </table>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. 暗号学的に安全な乱数生成器（CSPRNG）を使用して、予測不可能なランダムなバイト列を生成します。<br />
                2. Poly1305では256ビット（32バイト）の鍵を使用します。この鍵長は、MAC（メッセージ認証コード）のセキュリティを保証します。<br />
                3. 生成された鍵は秘密情報として扱い、安全に保管する必要があります。同じ鍵を使用することで、MACの計算と検証が可能になります。<br />
                4. 鍵は毎回ランダムに生成されるため、同じメッセージでも異なる認証タグが生成されます（実際には同じメッセージと鍵からは同じ認証タグが生成されます）。
              </div>
            </div>
          </div>

          <div class="step">
            <div class="step-title">
              <span class="step-number">2</span>
              MAC計算
              <button class="detail-toggle" @click="poly1305State.showDetails.mac = !poly1305State.showDetails.mac"
                x-show="poly1305State.tag">
                <span x-show="!poly1305State.showDetails.mac">詳細を表示</span>
                <span x-show="poly1305State.showDetails.mac">詳細を隠す</span>
              </button>
            </div>
            <div class="param-group">
              <label>メッセージ:</label>
              <textarea x-model="poly1305State.message" placeholder="MACを計算するメッセージを入力"></textarea>
            </div>
            <button @click="computePoly1305MAC()" :disabled="!poly1305State.key || !poly1305State.message">
              MACを計算
            </button>
            <div x-show="poly1305State.tag" class="output">
              <strong>認証タグ:</strong><br />
              <span x-text="formatBytes(poly1305State.tag)"></span>
            </div>
            <div x-show="poly1305State.showDetails.mac && poly1305State.tag" class="detail-section">
              <h4>🔍 MAC計算の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 入力（文字列）</div>
                  <div class="data-box-content" x-text="poly1305State.message || '(空)'"></div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. バイト配列に変換</div>
                  <div class="data-box-content" x-text="formatBytesReadable(poly1305State.messageBytes)"></div>
                  <div class="param-label">長さ: <span x-text="poly1305State.messageBytes?.length || 0"></span> バイト</div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. Poly1305でMAC計算</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    鍵 + メッセージ → 認証タグ（128ビット）
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">4. 出力（認証タグ）</div>
                  <div class="data-box-content" x-text="formatBytesReadable(poly1305State.tag)"></div>
                  <div class="param-label">長さ: <span x-text="poly1305State.tag?.length || 0"></span> バイト（128ビット）</div>
                </div>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. メッセージをUTF-8エンコーディングでバイト配列に変換します。<br />
                2. Poly1305アルゴリズムを使用して、鍵とメッセージから認証タグ（MAC）を計算します。<br />
                3. 認証タグは128ビット（16バイト）の固定長で、メッセージの完全性と真正性を保証します。<br />
                4. 同じ鍵とメッセージからは常に同じ認証タグが生成されます。
              </div>
            </div>
          </div>

          <div class="step">
            <div class="step-title">
              <span class="step-number">3</span>
              MAC検証
              <button class="detail-toggle"
                @click="poly1305State.showDetails.verification = !poly1305State.showDetails.verification"
                x-show="poly1305State.verified !== null">
                <span x-show="!poly1305State.showDetails.verification">詳細を表示</span>
                <span x-show="poly1305State.showDetails.verification">詳細を隠す</span>
              </button>
            </div>
            <div class="param-group">
              <label>検証するメッセージ:</label>
              <textarea x-model="poly1305State.verificationMessage"
                placeholder="検証するメッセージを入力（MAC計算時のメッセージと同じ場合は検証成功、異なる場合は検証失敗）"></textarea>
              <div class="param-label" style="margin-top: 5px;">
                <span x-show="poly1305State.message && poly1305State.verificationMessage">
                  <span x-show="poly1305State.message === poly1305State.verificationMessage" style="color: #2ecc71;">
                    ✓ MAC計算時のメッセージと一致
                  </span>
                  <span x-show="poly1305State.message !== poly1305State.verificationMessage" style="color: #e74c3c;">
                    ✗ MAC計算時のメッセージと異なります（検証は失敗します）
                  </span>
                </span>
              </div>
            </div>
            <button @click="verifyPoly1305MAC()" :disabled="!poly1305State.tag || !poly1305State.verificationMessage">
              MACを検証
            </button>
            <div x-show="poly1305State.verified !== null" class="output">
              <span x-show="poly1305State.verified" style="color: #2ecc71; font-weight: bold">
                ✓ 検証成功
              </span>
              <span x-show="!poly1305State.verified" style="color: #e74c3c; font-weight: bold">
                ✗ 検証失敗
              </span>
            </div>
            <div x-show="poly1305State.error" class="error" x-text="poly1305State.error"></div>
            <div x-show="poly1305State.showDetails.verification && poly1305State.verified !== null"
              class="detail-section">
              <h4>🔍 MAC検証の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 検証するメッセージ（文字列）</div>
                  <div class="data-box-content" x-text="poly1305State.verificationMessage || '(空)'"></div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. バイト配列に変換</div>
                  <div class="data-box-content" x-text="formatBytesReadable(poly1305State.verificationMessageBytes)">
                  </div>
                  <div class="param-label">長さ: <span
                      x-text="poly1305State.verificationMessageBytes?.length || 0"></span> バイト</div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. Poly1305でMAC再計算</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    鍵 + 検証メッセージ → 新しい認証タグ
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">4. 認証タグを比較</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    計算されたタグ vs 提供されたタグ<br />
                    <span x-show="poly1305State.verified" style="color: #2ecc71">✓ 一致</span>
                    <span x-show="!poly1305State.verified" style="color: #e74c3c">✗ 不一致</span>
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">5. 検証結果</div>
                  <div class="data-box-content">
                    <span x-show="poly1305State.verified" style="color: #2ecc71; font-weight: bold">
                      ✓ 検証成功（データは改ざんされていません）
                    </span>
                    <span x-show="!poly1305State.verified" style="color: #e74c3c; font-weight: bold">
                      ✗ 検証失敗（データが改ざんされている可能性があります）
                    </span>
                  </div>
                </div>
              </div>
              <div x-show="poly1305State.message && poly1305State.verificationMessage"
                style="margin-top: 15px; padding: 10px; background: #fff3cd; border-radius: 4px; font-size: 12px; border-left: 3px solid #ffc107;">
                <strong>メッセージ比較:</strong><br />
                <strong>MAC計算時のメッセージ:</strong> <span x-text="poly1305State.message"></span><br />
                <strong>検証時のメッセージ:</strong> <span x-text="poly1305State.verificationMessage"></span><br />
                <span x-show="poly1305State.message === poly1305State.verificationMessage"
                  style="color: #2ecc71; font-weight: bold;">
                  ✓ メッセージが一致しているため、検証は成功します
                </span>
                <span x-show="poly1305State.message !== poly1305State.verificationMessage"
                  style="color: #e74c3c; font-weight: bold;">
                  ✗ メッセージが異なるため、検証は失敗します（メッセージが改ざんされたことを検出）
                </span>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. 検証するメッセージをバイト配列に変換します。<br />
                2. 同じ鍵を使用して、メッセージから認証タグを再計算します。<br />
                3. 再計算された認証タグと提供された認証タグを定時間比較します（タイミング攻撃を防ぐため）。<br />
                4. 認証タグが一致する場合、メッセージは改ざんされていないことが確認されます。
              </div>
            </div>
          </div>
        </div>
      </div>
    </template>

    <!-- MAC - SipHash -->
    <template x-if="selectedCrypto === 'siphash'">
      <div>
        <div class="section">
          <h2>SipHash (MAC) の動作</h2>
          <div class="info">
            <strong>概要:</strong><br />
            SipHashは、短いメッセージに特化した高速な鍵付きハッシュ関数（MAC）です。<br />
            主な用途: ハッシュテーブルのDoS攻撃対策、メッセージ認証など<br />
            <br />
            <strong>特徴:</strong><br />
            • 鍵付きハッシュ関数（MAC）<br />
            • ARX構造<br />
            • 64ビット（8バイト）の固定長出力<br />
            • 短いメッセージに特化した高速なMAC
          </div>

          <!-- Input Section -->
          <div class="step">
            <div class="step-title">
              <span class="step-number">1</span>
              入力データ
              <button class="detail-toggle" @click="hashState.showDetails.input = !hashState.showDetails.input"
                x-show="hashState.inputText">
                <span x-show="!hashState.showDetails.input">詳細を表示</span>
                <span x-show="hashState.showDetails.input">詳細を隠す</span>
              </button>
            </div>

            <div class="param-group">
              <label for="hash-input-siphash">入力テキスト:</label>
              <textarea id="hash-input-siphash" x-model="hashState.inputText" rows="4"
                placeholder="ハッシュ値を計算したいテキストを入力してください"
                @input="hashState.error = ''; hashState.hash = null; hashState.comparisonResults = {};"></textarea>
            </div>

            <div x-show="hashState.inputText" class="output">
              <strong>入力サイズ:</strong>
              <span x-text="new TextEncoder().encode(hashState.inputText).length"></span> バイト
              (<span x-text="hashState.inputText.length"></span> 文字)
            </div>

            <div x-show="hashState.showDetails.input && hashState.inputText" class="detail-section">
              <h4>🔍 入力データの詳細</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. テキスト入力</div>
                  <div class="data-box-content" style="max-height: 100px; overflow: auto;" x-text="hashState.inputText">
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. UTF-8エンコード</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    TextEncoderを使用してバイト配列に変換
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. バイト配列</div>
                  <div class="data-box-content"
                    style="font-family: monospace; word-break: break-all; max-height: 100px; overflow: auto;">
                    <template
                      x-for="(byte, index) in Array.from(new TextEncoder().encode(hashState.inputText)).slice(0, 64)"
                      :key="index">
                      <span x-text="byte.toString(16).padStart(2, '0') + ' '"></span>
                    </template>
                    <span x-show="new TextEncoder().encode(hashState.inputText).length > 64">...</span>
                  </div>
                  <div class="param-label">
                    長さ: <span x-text="new TextEncoder().encode(hashState.inputText).length"></span> バイト
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Key Generation -->
          <div class="step">
            <div class="step-title">
              <span class="step-number">2</span>
              SipHash 鍵生成
              <button class="detail-toggle"
                @click="hashState.showDetails.keyGeneration = !hashState.showDetails.keyGeneration"
                x-show="hashState.siphashKey">
                <span x-show="!hashState.showDetails.keyGeneration">詳細を表示</span>
                <span x-show="hashState.showDetails.keyGeneration">詳細を隠す</span>
              </button>
            </div>
            <div class="info">
              SipHashは鍵付きハッシュ関数 (MAC) のため、128ビット (16バイト) の鍵が必要です。
            </div>
            <button @click="generateSipHashKey()">鍵を生成</button>
            <div x-show="hashState.siphashKey" class="output">
              <strong>生成された鍵 (16進数):</strong><br />
              <span style="font-family: monospace; word-break: break-all;">
                <template x-for="(byte, index) in Array.from(hashState.siphashKey || [])" :key="index">
                  <span x-text="byte.toString(16).padStart(2, '0') + ' '"></span>
                </template>
              </span>
            </div>
            <div x-show="hashState.showDetails.keyGeneration && hashState.siphashKey" class="detail-section">
              <h4>🔍 鍵生成の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 暗号学的に安全な乱数生成</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    CSPRNG（暗号学的擬似乱数生成器）を使用
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. 128ビット（16バイト）の鍵を生成</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    各バイトは0x00～0xFFのランダムな値
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. 生成された鍵</div>
                  <div class="data-box-content" style="font-family: monospace; word-break: break-all;">
                    <template x-for="(byte, index) in Array.from(hashState.siphashKey || [])" :key="index">
                      <span x-text="byte.toString(16).padStart(2, '0') + ' '"></span>
                    </template>
                  </div>
                  <div class="param-label">
                    長さ: 16 バイト（128 ビット）
                  </div>
                </div>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. SipHashは鍵付きハッシュ関数（MAC）であり、秘密鍵を使用してハッシュ値を計算します。<br />
                2. 128ビット（16バイト）の鍵は、暗号学的に安全な乱数生成器（CSPRNG）を使用して生成されます。<br />
                3. 同じ入力でも異なる鍵を使用すると、まったく異なるハッシュ値が生成されます。<br />
                4. 鍵を知らない第三者は、正しいハッシュ値を計算できません（メッセージ認証）。
              </div>
            </div>
          </div>

          <!-- Hash Computation -->
          <div class="step" x-init="hashState.selectedAlgorithm = 'siphash'; hashState.comparisonMode = false;">
            <div class="step-title">
              <span class="step-number">3</span>
              ハッシュ値の計算
              <button class="detail-toggle"
                @click="hashState.showDetails.processing = !hashState.showDetails.processing" x-show="hashState.hash">
                <span x-show="!hashState.showDetails.processing">詳細を表示</span>
                <span x-show="hashState.showDetails.processing">詳細を隠す</span>
              </button>
            </div>
            <button @click="computeHash()" :disabled="!hashState.inputText || !hashState.siphashKey">
              ハッシュ値を計算
            </button>

            <div x-show="hashState.hash" class="output">
              <strong>計算時間:</strong> <span x-text="hashState.processingTime.toFixed(3)"></span> ミリ秒<br />
              <strong>出力サイズ:</strong> <span x-text="(hashState.hash || []).length"></span> バイト
              (<span x-text="(hashState.hash || []).length * 8"></span> ビット)
            </div>

            <div x-show="hashState.showDetails.processing && hashState.hash" class="detail-section">
              <h4>🔍 ハッシュ計算の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 入力データ</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    UTF-8エンコードされたバイト配列
                  </div>
                  <div class="param-label">
                    <span x-text="new TextEncoder().encode(hashState.inputText).length"></span> バイト
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. SipHashでハッシュ化</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    SipHash (鍵付きハッシュ関数)<br />
                    鍵 + メッセージ → ハッシュ値（64ビット）
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. ハッシュ値</div>
                  <div class="data-box-content" style="font-family: monospace; word-break: break-all; font-size: 10px;">
                    <template x-for="(byte, index) in Array.from(hashState.hash || [])" :key="index">
                      <span x-text="byte.toString(16).padStart(2, '0') + ' '"></span>
                    </template>
                  </div>
                  <div class="param-label">
                    <span x-text="(hashState.hash || []).length"></span> バイト（固定長）
                  </div>
                </div>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. SipHashは鍵付きハッシュ関数（MAC）であり、秘密鍵を使用してハッシュ値を計算します。<br />
                2. 一方向性により、ハッシュ値から元のデータを復元することは計算量的に困難です。<br />
                3. 同じ入力でも異なる鍵を使用すると、まったく異なるハッシュ値が生成されます。<br />
                4. 鍵を知らない第三者は、正しいハッシュ値を計算できません（メッセージ認証）。
              </div>
            </div>
          </div>

          <!-- Output Section -->
          <div x-show="hashState.hash" class="step">
            <div class="step-title">
              <span class="step-number">4</span>
              ハッシュ値 (出力)
              <button class="detail-toggle" @click="hashState.showDetails.output = !hashState.showDetails.output"
                x-show="hashState.hash">
                <span x-show="!hashState.showDetails.output">詳細を表示</span>
                <span x-show="hashState.showDetails.output">詳細を隠す</span>
              </button>
            </div>

            <div x-show="hashState.hash" class="output">
              <strong>ハッシュ値 (16進数):</strong><br />
              <span style="word-break: break-all; font-family: monospace;"
                x-text="Array.from(hashState.hash || []).map(b => b.toString(16).padStart(2, '0')).join('')"></span><br /><br />
              <strong>ハッシュ値 (Base64):</strong><br />
              <span style="word-break: break-all; font-family: monospace;"
                x-text="btoa(String.fromCharCode(...Array.from(hashState.hash || [])))"></span><br /><br />
              <strong>出力サイズ:</strong> <span x-text="(hashState.hash || []).length"></span> バイト
              (<span x-text="(hashState.hash || []).length * 8"></span> ビット)
            </div>

            <div x-show="hashState.showDetails.output && hashState.hash" class="detail-section">
              <h4>🔍 ハッシュ値の詳細</h4>
              <div>
                <div class="data-flow">
                  <div class="data-box">
                    <div class="data-box-label">ハッシュ値 (16進数)</div>
                    <div class="data-box-content"
                      style="font-family: monospace; word-break: break-all; font-size: 10px;">
                      <span
                        x-text="Array.from(hashState.hash || []).map(b => b.toString(16).padStart(2, '0')).join('')"></span>
                    </div>
                    <div class="param-label">
                      長さ: <span x-text="(hashState.hash || []).length"></span> バイト
                      (<span x-text="(hashState.hash || []).length * 8"></span> ビット)
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- MAC Properties -->
          <div class="section">
            <h3>MAC (Message Authentication Code) の性質</h3>
            <div class="info">
              <strong>鍵付きハッシュ関数の要件:</strong><br />
              1. <strong>鍵依存性</strong>: 異なる鍵から異なるハッシュ値が生成される<br />
              2. <strong>一方向性</strong>: ハッシュ値から元のデータを復元することが計算量的に困難<br />
              3. <strong>固定長出力</strong>: 入力の長さに関わらず、常に固定長の出力を生成<br />
              4. <strong>メッセージ認証</strong>: 鍵を知らない第三者は、正しいハッシュ値を計算できない<br />
              <br />
              <strong>構造:</strong><br />
              • <strong>SipHash</strong>: ARX構造 (MAC用途に最適化)
            </div>
          </div>

          <div x-show="hashState.error" style="color: #e74c3c; margin-top: 10px;" x-text="hashState.error"></div>
        </div>
      </div>
    </template>

    <template x-if="selectedCrypto === 'rsa'">
      <div>
        <div class="section">
          <h2>RSA (Rivest-Shamir-Adleman) の動作</h2>
          <div class="info">
            <strong>初期化パラメータ:</strong><br />
            鍵サイズ: <select x-model="rsaState.keySize" style="width: auto; display: inline-block; margin-left: 10px;">
              <option :value="2048">2048ビット</option>
              <option :value="4096">4096ビット</option>
            </select><br />
            RSA-OAEPパディングを使用
          </div>

          <!-- モード選択タブ -->
          <div class="mode-tabs" x-show="rsaState.keyPair">
            <button class="mode-tab" :class="{ active: rsaState.mode === 'encryption' }"
              @click="rsaState.mode = 'encryption'">暗号化・復号</button>
            <button class="mode-tab" :class="{ active: rsaState.mode === 'signature' }"
              @click="rsaState.mode = 'signature'">署名・検証</button>
          </div>

          <!-- 鍵生成 -->
          <div class="step">
            <div class="step-title">
              <span class="step-number">1</span>
              鍵ペアの生成
              <button class="detail-toggle"
                @click="rsaState.showDetails.keyGeneration = !rsaState.showDetails.keyGeneration"
                x-show="rsaState.keyPair">
                <span x-show="!rsaState.showDetails.keyGeneration">詳細を表示</span>
                <span x-show="rsaState.showDetails.keyGeneration">詳細を隠す</span>
              </button>
            </div>
            <button @click="generateRsaKeyPair()">鍵ペアを生成</button>
            <div x-show="rsaState.keyPair" style="margin-top: 15px;">
              <div class="data-box">
                <div class="data-box-label">公開鍵（PEM形式）</div>
                <div class="data-box-content" style="word-break: break-all; font-size: 11px;"
                  x-text="rsaState.keyPair?.publicKey"></div>
              </div>
              <div class="data-box" style="margin-top: 10px;">
                <div class="data-box-label">秘密鍵（PEM形式）</div>
                <div class="data-box-content" style="word-break: break-all; font-size: 11px;"
                  x-text="rsaState.keyPair?.privateKey"></div>
              </div>
            </div>
            <div x-show="rsaState.showDetails.keyGeneration && rsaState.keyPair" class="detail-section">
              <h4>🔍 鍵生成の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 鍵サイズの選択</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    <span x-text="rsaState.keySize"></span>ビットの鍵サイズを選択
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. 素数pとqを生成</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    暗号学的に安全な乱数生成器を使用して、大きな素数を生成
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. 公開鍵と秘密鍵を計算</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    n = p × q（モジュラス）<br />
                    公開鍵: (n, e)<br />
                    秘密鍵: (n, d)
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">4. PEM形式でエクスポート</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    ASN.1形式でエンコードし、Base64でエンコード
                  </div>
                </div>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. RSA鍵ペアは、2つの大きな素数pとqから生成されます。これらの素数は暗号学的に安全な乱数生成器を使用して生成されます。<br />
                2. モジュラスn = p × qを計算し、公開指数e（通常65537）と秘密指数dを計算します。<br />
                3. 公開鍵は(n, e)のペア、秘密鍵は(n, d)のペアとして表現されます。<br />
                4. 鍵はPEM形式（Privacy-Enhanced Mail）でエクスポートされ、Base64エンコードされたASN.1構造として保存されます。
              </div>
            </div>
            <div x-show="rsaState.error" style="color: #e74c3c; margin-top: 10px;" x-text="rsaState.error"></div>
          </div>

          <!-- 暗号化 -->
          <div class="step" x-show="rsaState.keyPair && rsaState.mode === 'encryption'">
            <div class="step-title">
              <span class="step-number">2</span>
              暗号化
              <button class="detail-toggle" @click="rsaState.showDetails.encryption = !rsaState.showDetails.encryption"
                x-show="rsaState.ciphertext">
                <span x-show="!rsaState.showDetails.encryption">詳細を表示</span>
                <span x-show="rsaState.showDetails.encryption">詳細を隠す</span>
              </button>
            </div>
            <label>平文:</label>
            <textarea x-model="rsaState.plaintext" placeholder="暗号化するメッセージを入力"></textarea>
            <button @click="encryptRSA()" :disabled="!rsaState.keyPair || !rsaState.plaintext">暗号化</button>
            <div x-show="rsaState.ciphertext" style="margin-top: 15px;">
              <div class="data-box">
                <div class="data-box-label">暗号文（16進数）</div>
                <div class="data-box-content" style="word-break: break-all; font-size: 11px;"
                  x-text="rsaState.ciphertext"></div>
              </div>
            </div>
            <div x-show="rsaState.showDetails.encryption && rsaState.ciphertext" class="detail-section">
              <h4>🔍 暗号化の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 入力（文字列）</div>
                  <div class="data-box-content" x-text="rsaState.plaintext || '(空)'"></div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. バイト配列に変換</div>
                  <div class="data-box-content" x-text="formatBytesReadable(rsaState.plaintextBytes)"></div>
                  <div class="param-label">長さ: <span x-text="rsaState.plaintextBytes?.length || 0"></span> バイト</div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. RSA-OAEPパディング</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    OAEP（Optimal Asymmetric Encryption Padding）を適用してパディング
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">4. 公開鍵で暗号化</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    c = m^e mod n<br />
                    （m: パディングされた平文、e: 公開指数、n: モジュラス）
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">5. 出力（暗号文）</div>
                  <div class="data-box-content"
                    x-text="rsaState.ciphertext.match(/.{1,64}/g)?.join(' ') || rsaState.ciphertext"></div>
                  <div class="param-label">長さ: <span x-text="(rsaState.ciphertext?.length || 0) / 2"></span> バイト</div>
                </div>
              </div>
              <div class="bytes-detail" x-show="rsaState.plaintextBytes">
                <h4>平文のバイト詳細</h4>
                <table>
                  <thead>
                    <tr>
                      <th>位置</th>
                      <th>16進数</th>
                      <th>10進数</th>
                      <th>ASCII</th>
                      <th>文字</th>
                    </tr>
                  </thead>
                  <tbody>
                    <template x-for="(byte, index) in Array.from(rsaState.plaintextBytes || [])" :key="index">
                      <tr>
                        <td x-text="index"></td>
                        <td x-text="byte.toString(16).padStart(2, '0')"></td>
                        <td x-text="byte"></td>
                        <td x-text="byte >= 32 && byte <= 126 ? String.fromCharCode(byte) : '.'"></td>
                        <td x-text="byte >= 32 && byte <= 126 ? String.fromCharCode(byte) : '(制御文字)'"></td>
                      </tr>
                    </template>
                  </tbody>
                </table>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. 平文をUTF-8エンコーディングでバイト配列に変換します。<br />
                2. RSA-OAEPパディングを適用します。OAEPは、RSAの脆弱性を防ぐためのパディング方式で、確率的パディングを使用します。<br />
                3. 公開鍵(n, e)を使用して、パディングされた平文を暗号化します。暗号文c = m^e mod nとして計算されます。<br />
                4. 暗号文は16進数文字列として出力されます。RSAの暗号文のサイズは鍵サイズと同じです（2048ビット鍵の場合、256バイト）。
              </div>
            </div>
            <div x-show="rsaState.error" style="color: #e74c3c; margin-top: 10px;" x-text="rsaState.error"></div>
          </div>

          <!-- 復号化 -->
          <div class="step" x-show="rsaState.ciphertext && rsaState.mode === 'encryption'">
            <div class="step-title">
              <span class="step-number">3</span>
              復号化
              <button class="detail-toggle" @click="rsaState.showDetails.decryption = !rsaState.showDetails.decryption"
                x-show="rsaState.decrypted">
                <span x-show="!rsaState.showDetails.decryption">詳細を表示</span>
                <span x-show="rsaState.showDetails.decryption">詳細を隠す</span>
              </button>
            </div>
            <button @click="decryptRSA()" :disabled="!rsaState.ciphertext">復号化</button>
            <div x-show="rsaState.decrypted" class="output" x-text="rsaState.decrypted"></div>
            <div x-show="rsaState.showDetails.decryption && rsaState.decrypted" class="detail-section">
              <h4>🔍 復号化の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 入力（暗号文）</div>
                  <div class="data-box-content"
                    x-text="rsaState.ciphertext.match(/.{1,64}/g)?.join(' ') || rsaState.ciphertext"></div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. 16進数をバイト配列に変換</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    16進数文字列をバイト配列に変換
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. 秘密鍵で復号</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    m = c^d mod n<br />
                    （c: 暗号文、d: 秘密指数、n: モジュラス）
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">4. OAEPパディングを除去</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    OAEPパディングを検証して除去
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">5. バイト配列を文字列に変換</div>
                  <div class="data-box-content" x-text="formatBytesReadable(rsaState.decryptedBytes)"></div>
                  <div class="param-label">長さ: <span x-text="rsaState.decryptedBytes?.length || 0"></span> バイト</div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">6. 出力（文字列）</div>
                  <div class="data-box-content" x-text="rsaState.decrypted"></div>
                </div>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. 16進数文字列の暗号文をバイト配列に変換します。<br />
                2. 秘密鍵(n, d)を使用して、暗号文を復号します。平文m = c^d mod nとして計算されます。<br />
                3. OAEPパディングを検証して除去します。パディングが無効な場合、エラーが発生します。<br />
                4. 復号されたバイト配列をUTF-8デコードして文字列に変換します。
              </div>
            </div>
            <div x-show="rsaState.error" style="color: #e74c3c; margin-top: 10px;" x-text="rsaState.error"></div>
          </div>

          <!-- 署名 -->
          <div class="step" x-show="rsaState.keyPair && rsaState.mode === 'signature'">
            <div class="step-title">
              <span class="step-number">2</span>
              デジタル署名
              <button class="detail-toggle" @click="rsaState.showDetails.signing = !rsaState.showDetails.signing"
                x-show="rsaState.signature">
                <span x-show="!rsaState.showDetails.signing">詳細を表示</span>
                <span x-show="rsaState.showDetails.signing">詳細を隠す</span>
              </button>
            </div>
            <label>署名するメッセージ:</label>
            <textarea x-model="rsaState.signatureMessage" placeholder="署名するメッセージを入力"></textarea>
            <button @click="signRSA()" :disabled="!rsaState.keyPair || !rsaState.signatureMessage">署名</button>
            <div x-show="rsaState.signature" style="margin-top: 15px;">
              <div class="data-box">
                <div class="data-box-label">署名（16進数）</div>
                <div class="data-box-content" style="word-break: break-all; font-size: 11px;"
                  x-text="rsaState.signature"></div>
              </div>
            </div>
            <div x-show="rsaState.showDetails.signing && rsaState.signature" class="detail-section">
              <h4>🔍 署名の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 入力（文字列）</div>
                  <div class="data-box-content" x-text="rsaState.signatureMessage || '(空)'"></div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. バイト配列に変換</div>
                  <div class="data-box-content" x-text="formatBytesReadable(rsaState.signatureMessageBytes)"></div>
                  <div class="param-label">長さ: <span x-text="rsaState.signatureMessageBytes?.length || 0"></span> バイト
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. SHA-256でハッシュ化</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    メッセージをSHA-256でハッシュ化（32バイト）
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">4. 秘密鍵で署名</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    s = H(m)^d mod n<br />
                    （H(m): ハッシュ値、d: 秘密指数、n: モジュラス）
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">5. 出力（署名）</div>
                  <div class="data-box-content"
                    x-text="rsaState.signature.match(/.{1,64}/g)?.join(' ') || rsaState.signature"></div>
                  <div class="param-label">長さ: <span x-text="(rsaState.signature?.length || 0) / 2"></span> バイト</div>
                </div>
              </div>
              <div class="bytes-detail" x-show="rsaState.signatureMessageBytes">
                <h4>メッセージのバイト詳細</h4>
                <table>
                  <thead>
                    <tr>
                      <th>位置</th>
                      <th>16進数</th>
                      <th>10進数</th>
                      <th>ASCII</th>
                      <th>文字</th>
                    </tr>
                  </thead>
                  <tbody>
                    <template x-for="(byte, index) in Array.from(rsaState.signatureMessageBytes || [])" :key="index">
                      <tr>
                        <td x-text="index"></td>
                        <td x-text="byte.toString(16).padStart(2, '0')"></td>
                        <td x-text="byte"></td>
                        <td x-text="byte >= 32 && byte <= 126 ? String.fromCharCode(byte) : '.'"></td>
                        <td x-text="byte >= 32 && byte <= 126 ? String.fromCharCode(byte) : '(制御文字)'"></td>
                      </tr>
                    </template>
                  </tbody>
                </table>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. 署名するメッセージをUTF-8エンコーディングでバイト配列に変換します。<br />
                2. メッセージをSHA-256でハッシュ化します。これにより、任意の長さのメッセージを固定長（32バイト）のハッシュ値に変換します。<br />
                3. 秘密鍵(n, d)を使用して、ハッシュ値を署名します。署名s = H(m)^d mod nとして計算されます。<br />
                4. 署名は16進数文字列として出力されます。RSA署名のサイズは鍵サイズと同じです（2048ビット鍵の場合、256バイト）。
              </div>
            </div>
            <div x-show="rsaState.error" style="color: #e74c3c; margin-top: 10px;" x-text="rsaState.error"></div>
          </div>

          <!-- 署名検証 -->
          <div class="step" x-show="rsaState.signature && rsaState.mode === 'signature'">
            <div class="step-title">
              <span class="step-number">3</span>
              署名の検証
              <button class="detail-toggle"
                @click="rsaState.showDetails.verification = !rsaState.showDetails.verification"
                x-show="rsaState.verified !== null">
                <span x-show="!rsaState.showDetails.verification">詳細を表示</span>
                <span x-show="rsaState.showDetails.verification">詳細を隠す</span>
              </button>
            </div>
            <label>検証するメッセージ:</label>
            <textarea x-model="rsaState.verificationMessage" placeholder="検証するメッセージを入力"></textarea>
            <button @click="verifyRSA()" :disabled="!rsaState.signature || !rsaState.verificationMessage">検証</button>
            <div x-show="rsaState.verified !== null" style="margin-top: 15px;">
              <div class="data-box"
                :style="rsaState.verified ? 'border-left-color: #2ecc71;' : 'border-left-color: #e74c3c;'">
                <div class="data-box-label">検証結果</div>
                <div class="data-box-content"
                  :style="rsaState.verified ? 'color: #2ecc71; font-weight: bold;' : 'color: #e74c3c; font-weight: bold;'">
                  <span x-show="rsaState.verified">✓ 署名は有効です</span>
                  <span x-show="!rsaState.verified">✗ 署名は無効です</span>
                </div>
              </div>
            </div>
            <div x-show="rsaState.showDetails.verification && rsaState.verified !== null" class="detail-section">
              <h4>🔍 検証の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 入力（メッセージ）</div>
                  <div class="data-box-content" x-text="rsaState.verificationMessage || '(空)'"></div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. バイト配列に変換</div>
                  <div class="data-box-content" x-text="formatBytesReadable(rsaState.verificationMessageBytes)"></div>
                  <div class="param-label">長さ: <span x-text="rsaState.verificationMessageBytes?.length || 0"></span> バイト
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. SHA-256でハッシュ化</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    メッセージをSHA-256でハッシュ化（32バイト）
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">4. 公開鍵で署名を復号</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    H'(m) = s^e mod n<br />
                    （s: 署名、e: 公開指数、n: モジュラス）
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">5. ハッシュ値を比較</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    H(m) === H'(m) かどうかを検証
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">6. 検証結果</div>
                  <div class="data-box-content"
                    :style="rsaState.verified ? 'color: #2ecc71; font-weight: bold;' : 'color: #e74c3c; font-weight: bold;'">
                    <span x-show="rsaState.verified">✓ 有効</span>
                    <span x-show="!rsaState.verified">✗ 無効</span>
                  </div>
                </div>
              </div>
              <div
                style="margin-top: 15px; padding: 10px; background: #fff3cd; border-radius: 4px; font-size: 12px; border-left: 3px solid #ffc107;">
                <strong>メッセージ比較:</strong><br />
                <strong>署名時のメッセージ:</strong> <span x-text="rsaState.signatureMessage"></span><br />
                <strong>検証時のメッセージ:</strong> <span x-text="rsaState.verificationMessage"></span><br />
                <span x-show="rsaState.signatureMessage === rsaState.verificationMessage"
                  style="color: #2ecc71; font-weight: bold;">
                  ✓ メッセージが一致しているため、検証は成功します
                </span>
                <span x-show="rsaState.signatureMessage !== rsaState.verificationMessage"
                  style="color: #e74c3c; font-weight: bold;">
                  ✗ メッセージが異なるため、検証は失敗します（メッセージが改ざんされたことを検出）
                </span>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. 検証するメッセージをUTF-8エンコーディングでバイト配列に変換します。<br />
                2. メッセージをSHA-256でハッシュ化します。<br />
                3. 公開鍵(n, e)を使用して、署名を復号します。復号されたハッシュ値H'(m) = s^e mod nとして計算されます。<br />
                4. メッセージから計算したハッシュ値H(m)と、署名から復号したハッシュ値H'(m)を比較します。<br />
                5. ハッシュ値が一致する場合、署名は有効です。一致しない場合、署名は無効です（メッセージが改ざんされた可能性があります）。
              </div>
            </div>
            <div x-show="rsaState.error" style="color: #e74c3c; margin-top: 10px;" x-text="rsaState.error"></div>
          </div>
        </div>
      </div>
    </template>

    <template x-if="selectedCrypto === 'ecc'">
      <div>
        <div class="section">
          <h2>ECC (Elliptic Curve Cryptography) の動作</h2>
          <div class="info">
            <strong>初期化パラメータ:</strong><br />
            楕円曲線: <select x-model="eccState.curve" style="width: auto; display: inline-block; margin-left: 10px;">
              <option value="secp256k1">secp256k1 (Bitcoin)</option>
              <option value="p256">P-256 (NIST)</option>
              <option value="p384">P-384 (NIST)</option>
              <option value="p521">P-521 (NIST)</option>
              <option value="ed25519">Ed25519 (EdDSA)</option>
              <option value="ed448">Ed448 (EdDSA)</option>
            </select>
          </div>

          <!-- モード選択タブ -->
          <div class="mode-tabs" x-show="eccState.keyPair">
            <button class="mode-tab" :class="{ active: eccState.mode === 'signature' }"
              @click="eccState.mode = 'signature'">署名・検証</button>
            <button class="mode-tab" :class="{ active: eccState.mode === 'ecdh' }" @click="eccState.mode = 'ecdh'"
              x-show="eccState.curve === 'secp256k1' || eccState.curve === 'p256' || eccState.curve === 'p384' || eccState.curve === 'p521'">ECDH鍵共有</button>
          </div>

          <!-- 鍵生成 -->
          <div class="step">
            <div class="step-title">
              <span class="step-number">1</span>
              鍵ペアの生成
              <button class="detail-toggle"
                @click="eccState.showDetails.keyGeneration = !eccState.showDetails.keyGeneration"
                x-show="eccState.keyPair">
                <span x-show="!eccState.showDetails.keyGeneration">詳細を表示</span>
                <span x-show="eccState.showDetails.keyGeneration">詳細を隠す</span>
              </button>
            </div>
            <button @click="generateEccKeyPair()">鍵ペアを生成</button>
            <div x-show="eccState.keyPair" style="margin-top: 15px;">
              <div class="data-box">
                <div class="data-box-label">公開鍵（16進数）</div>
                <div class="data-box-content" style="word-break: break-all; font-size: 11px;"
                  x-text="eccState.keyPair?.publicKey"></div>
              </div>
              <div class="data-box" style="margin-top: 10px;">
                <div class="data-box-label">秘密鍵（16進数）</div>
                <div class="data-box-content" style="word-break: break-all; font-size: 11px;"
                  x-text="eccState.keyPair?.privateKey"></div>
              </div>
            </div>
            <div x-show="eccState.showDetails.keyGeneration && eccState.keyPair" class="detail-section">
              <h4>🔍 鍵生成の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 曲線の選択</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    楕円曲線: <span x-text="eccState.curve"></span>
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. 秘密鍵を生成</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    暗号学的に安全な乱数生成器を使用して、曲線の位数未満のランダムな整数を生成
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. 公開鍵を計算</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    Q = d × G<br />
                    （d: 秘密鍵、G: ベースポイント、Q: 公開鍵）
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">4. 鍵を16進数でエクスポート</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    秘密鍵と公開鍵を16進数文字列として出力
                  </div>
                </div>
              </div>
              <div class="bytes-detail" x-show="eccState.keyPair">
                <h4>秘密鍵のバイト詳細</h4>
                <div x-show="eccState.keyPair?.privateKey">
                  <template x-if="eccState.keyPair?.privateKey">
                    <table>
                      <thead>
                        <tr>
                          <th>位置</th>
                          <th>16進数</th>
                          <th>10進数</th>
                          <th>2進数（8ビット）</th>
                        </tr>
                      </thead>
                      <tbody>
                        <template
                          x-for="(byte, index) in Array.from(cryptoApp.hexToBytes(eccState.keyPair?.privateKey || ''))"
                          :key="index">
                          <tr>
                            <td x-text="index"></td>
                            <td x-text="byte.toString(16).padStart(2, '0').toUpperCase()"></td>
                            <td x-text="byte"></td>
                            <td x-text="byte.toString(2).padStart(8, '0')"></td>
                          </tr>
                        </template>
                      </tbody>
                    </table>
                  </template>
                </div>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. 選択された楕円曲線に基づいて、適切なパラメータ（ベースポイントG、位数など）を設定します。<br />
                2. 暗号学的に安全な乱数生成器を使用して、曲線の位数未満のランダムな整数を秘密鍵として生成します。<br />
                3. 楕円曲線上のスカラー倍算を使用して、秘密鍵dから公開鍵Q = d × Gを計算します。これは楕円曲線上の点です。<br />
                4. 秘密鍵と公開鍵を16進数文字列として出力します。ECCでは、同じセキュリティ強度をRSAよりも短い鍵長で実現できます。
              </div>
            </div>
            <div x-show="eccState.error" style="color: #e74c3c; margin-top: 10px;" x-text="eccState.error"></div>
          </div>

          <!-- 署名 -->
          <div class="step" x-show="eccState.keyPair && eccState.mode === 'signature'">
            <div class="step-title">
              <span class="step-number">2</span>
              デジタル署名
              <button class="detail-toggle" @click="eccState.showDetails.signing = !eccState.showDetails.signing"
                x-show="eccState.signature">
                <span x-show="!eccState.showDetails.signing">詳細を表示</span>
                <span x-show="eccState.showDetails.signing">詳細を隠す</span>
              </button>
            </div>
            <label>署名するメッセージ:</label>
            <textarea x-model="eccState.signatureMessage" placeholder="署名するメッセージを入力"></textarea>
            <button @click="signECC()" :disabled="!eccState.keyPair || !eccState.signatureMessage">署名</button>
            <div x-show="eccState.signature" style="margin-top: 15px;">
              <div class="data-box">
                <div class="data-box-label">署名（16進数）</div>
                <div class="data-box-content" style="word-break: break-all; font-size: 11px;"
                  x-text="eccState.signature"></div>
              </div>
            </div>
            <div x-show="eccState.showDetails.signing && eccState.signature" class="detail-section">
              <h4>🔍 署名の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 入力（文字列）</div>
                  <div class="data-box-content" x-text="eccState.signatureMessage || '(空)'"></div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. バイト配列に変換</div>
                  <div class="data-box-content" x-text="formatBytesReadable(eccState.signatureMessageBytes)"></div>
                  <div class="param-label">長さ: <span x-text="eccState.signatureMessageBytes?.length || 0"></span> バイト
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. 署名アルゴリズムの選択</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    <span x-show="eccState.curve === 'ed25519' || eccState.curve === 'ed448'">EdDSA（Edwards曲線）</span>
                    <span
                      x-show="eccState.curve !== 'ed25519' && eccState.curve !== 'ed448'">ECDSA（Weierstrass曲線）</span>
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">4. 楕円曲線で署名</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    <span x-show="eccState.curve === 'ed25519' || eccState.curve === 'ed448'">
                      EdDSA: メッセージと秘密鍵から署名を生成
                    </span>
                    <span x-show="eccState.curve !== 'ed25519' && eccState.curve !== 'ed448'">
                      ECDSA: (r, s) = 署名値<br />
                      r, sは曲線上の点の座標から計算
                    </span>
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">5. 出力（署名）</div>
                  <div class="data-box-content"
                    x-text="eccState.signature.match(/.{1,64}/g)?.join(' ') || eccState.signature"></div>
                  <div class="param-label">長さ: <span x-text="(eccState.signature?.length || 0) / 2"></span> バイト</div>
                </div>
              </div>
              <div class="bytes-detail" x-show="eccState.signatureMessageBytes">
                <h4>メッセージのバイト詳細</h4>
                <table>
                  <thead>
                    <tr>
                      <th>位置</th>
                      <th>16進数</th>
                      <th>10進数</th>
                      <th>ASCII</th>
                      <th>文字</th>
                    </tr>
                  </thead>
                  <tbody>
                    <template x-for="(byte, index) in Array.from(eccState.signatureMessageBytes || [])" :key="index">
                      <tr>
                        <td x-text="index"></td>
                        <td x-text="byte.toString(16).padStart(2, '0')"></td>
                        <td x-text="byte"></td>
                        <td x-text="byte >= 32 && byte <= 126 ? String.fromCharCode(byte) : '.'"></td>
                        <td x-text="byte >= 32 && byte <= 126 ? String.fromCharCode(byte) : '(制御文字)'"></td>
                      </tr>
                    </template>
                  </tbody>
                </table>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                <span x-show="eccState.curve === 'ed25519' || eccState.curve === 'ed448'">
                  1. メッセージをUTF-8エンコーディングでバイト配列に変換します。<br />
                  2. EdDSA（Edwards-curve Digital Signature
                  Algorithm）を使用して署名を生成します。EdDSAは、Edwards曲線を使用したデジタル署名アルゴリズムです。<br />
                  3. EdDSAは、メッセージと秘密鍵から直接署名を計算します。ハッシュ化と署名生成が統合されています。<br />
                  4. 署名は16進数文字列として出力されます。Ed25519の署名は64バイト、Ed448の署名は114バイトです。
                </span>
                <span x-show="eccState.curve !== 'ed25519' && eccState.curve !== 'ed448'">
                  1. メッセージをUTF-8エンコーディングでバイト配列に変換します。<br />
                  2. ECDSA（Elliptic Curve Digital Signature
                  Algorithm）を使用して署名を生成します。ECDSAは、楕円曲線を使用したデジタル署名アルゴリズムです。<br />
                  3. メッセージをハッシュ化し、楕円曲線上の演算を使用して署名値(r, s)を計算します。<br />
                  4. 署名は16進数文字列として出力されます。署名のサイズは曲線によって異なります（secp256k1/P-256: 64バイト、P-384: 96バイト、P-521: 132バイト）。
                </span>
              </div>
            </div>
            <div x-show="eccState.error" style="color: #e74c3c; margin-top: 10px;" x-text="eccState.error"></div>
          </div>

          <!-- 署名検証 -->
          <div class="step" x-show="eccState.signature && eccState.mode === 'signature'">
            <div class="step-title">
              <span class="step-number">3</span>
              署名の検証
              <button class="detail-toggle"
                @click="eccState.showDetails.verification = !eccState.showDetails.verification"
                x-show="eccState.verified !== null">
                <span x-show="!eccState.showDetails.verification">詳細を表示</span>
                <span x-show="eccState.showDetails.verification">詳細を隠す</span>
              </button>
            </div>
            <label>検証するメッセージ:</label>
            <textarea x-model="eccState.verificationMessage" placeholder="検証するメッセージを入力"></textarea>
            <button @click="verifyECC()" :disabled="!eccState.signature || !eccState.verificationMessage">検証</button>
            <div x-show="eccState.verified !== null" style="margin-top: 15px;">
              <div class="data-box"
                :style="eccState.verified ? 'border-left-color: #2ecc71;' : 'border-left-color: #e74c3c;'">
                <div class="data-box-label">検証結果</div>
                <div class="data-box-content"
                  :style="eccState.verified ? 'color: #2ecc71; font-weight: bold;' : 'color: #e74c3c; font-weight: bold;'">
                  <span x-show="eccState.verified">✓ 署名は有効です</span>
                  <span x-show="!eccState.verified">✗ 署名は無効です</span>
                </div>
              </div>
            </div>
            <div x-show="eccState.showDetails.verification && eccState.verified !== null" class="detail-section">
              <h4>🔍 検証の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 入力（メッセージ）</div>
                  <div class="data-box-content" x-text="eccState.verificationMessage || '(空)'"></div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. バイト配列に変換</div>
                  <div class="data-box-content" x-text="formatBytesReadable(eccState.verificationMessageBytes)"></div>
                  <div class="param-label">長さ: <span x-text="eccState.verificationMessageBytes?.length || 0"></span> バイト
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. 署名アルゴリズムの選択</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    <span x-show="eccState.curve === 'ed25519' || eccState.curve === 'ed448'">EdDSA（Edwards曲線）</span>
                    <span
                      x-show="eccState.curve !== 'ed25519' && eccState.curve !== 'ed448'">ECDSA（Weierstrass曲線）</span>
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">4. 楕円曲線で検証</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    <span x-show="eccState.curve === 'ed25519' || eccState.curve === 'ed448'">
                      EdDSA: メッセージ、署名、公開鍵から検証
                    </span>
                    <span x-show="eccState.curve !== 'ed25519' && eccState.curve !== 'ed448'">
                      ECDSA: 楕円曲線上の演算で署名を検証
                    </span>
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">5. 検証結果</div>
                  <div class="data-box-content"
                    :style="eccState.verified ? 'color: #2ecc71; font-weight: bold;' : 'color: #e74c3c; font-weight: bold;'">
                    <span x-show="eccState.verified">✓ 有効</span>
                    <span x-show="!eccState.verified">✗ 無効</span>
                  </div>
                </div>
              </div>
              <div
                style="margin-top: 15px; padding: 10px; background: #fff3cd; border-radius: 4px; font-size: 12px; border-left: 3px solid #ffc107;">
                <strong>メッセージ比較:</strong><br />
                <strong>署名時のメッセージ:</strong> <span x-text="eccState.signatureMessage"></span><br />
                <strong>検証時のメッセージ:</strong> <span x-text="eccState.verificationMessage"></span><br />
                <span x-show="eccState.signatureMessage === eccState.verificationMessage"
                  style="color: #2ecc71; font-weight: bold;">
                  ✓ メッセージが一致しているため、検証は成功します
                </span>
                <span x-show="eccState.signatureMessage !== eccState.verificationMessage"
                  style="color: #e74c3c; font-weight: bold;">
                  ✗ メッセージが異なるため、検証は失敗します（メッセージが改ざんされたことを検出）
                </span>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                <span x-show="eccState.curve === 'ed25519' || eccState.curve === 'ed448'">
                  1. 検証するメッセージをUTF-8エンコーディングでバイト配列に変換します。<br />
                  2. EdDSAを使用して、メッセージ、署名、公開鍵から署名の有効性を検証します。<br />
                  3. 楕円曲線上の演算を使用して、署名が正しいことを確認します。<br />
                  4. 検証が成功した場合、署名は有効です。失敗した場合、署名は無効です（メッセージが改ざんされた可能性があります）。
                </span>
                <span x-show="eccState.curve !== 'ed25519' && eccState.curve !== 'ed448'">
                  1. 検証するメッセージをUTF-8エンコーディングでバイト配列に変換します。<br />
                  2. メッセージをハッシュ化します。<br />
                  3. ECDSAを使用して、ハッシュ値、署名、公開鍵から署名の有効性を検証します。<br />
                  4. 楕円曲線上の演算を使用して、署名値(r, s)が正しいことを確認します。<br />
                  5. 検証が成功した場合、署名は有効です。失敗した場合、署名は無効です（メッセージが改ざんされた可能性があります）。
                </span>
              </div>
            </div>
            <div x-show="eccState.error" style="color: #e74c3c; margin-top: 10px;" x-text="eccState.error"></div>
          </div>

          <!-- ECDH -->
          <div class="step"
            x-show="eccState.keyPair && eccState.mode === 'ecdh' && (eccState.curve === 'secp256k1' || eccState.curve === 'p256' || eccState.curve === 'p384' || eccState.curve === 'p521')">
            <div class="step-title">
              <span class="step-number">2</span>
              ECDH鍵共有
              <button class="detail-toggle" @click="eccState.showDetails.ecdh = !eccState.showDetails.ecdh"
                x-show="eccState.sharedSecret">
                <span x-show="!eccState.showDetails.ecdh">詳細を表示</span>
                <span x-show="eccState.showDetails.ecdh">詳細を隠す</span>
              </button>
            </div>
            <label>自分の秘密鍵（16進数）:</label>
            <input type="text" x-model="eccState.ecdhPrivateKey" placeholder="秘密鍵を入力">
            <label style="margin-top: 10px;">相手の公開鍵（16進数）:</label>
            <input type="text" x-model="eccState.ecdhPublicKey" placeholder="公開鍵を入力">
            <button @click="computeECDH()"
              :disabled="!eccState.ecdhPrivateKey || !eccState.ecdhPublicKey">共有秘密鍵を計算</button>
            <div x-show="eccState.sharedSecret" style="margin-top: 15px;">
              <div class="data-box">
                <div class="data-box-label">共有秘密鍵（16進数）</div>
                <div class="data-box-content" style="word-break: break-all; font-size: 11px;"
                  x-text="eccState.sharedSecret"></div>
              </div>
            </div>
            <div x-show="eccState.showDetails.ecdh && eccState.sharedSecret" class="detail-section">
              <h4>🔍 ECDH鍵共有の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 自分の秘密鍵</div>
                  <div class="data-box-content" style="font-size: 10px; word-break: break-all;"
                    x-text="eccState.ecdhPrivateKey"></div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. 相手の公開鍵</div>
                  <div class="data-box-content" style="font-size: 10px; word-break: break-all;"
                    x-text="eccState.ecdhPublicKey"></div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. 楕円曲線上のスカラー倍算</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    S = d_A × Q_B<br />
                    （d_A: 自分の秘密鍵、Q_B: 相手の公開鍵、S: 共有秘密鍵）
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">4. 出力（共有秘密鍵）</div>
                  <div class="data-box-content"
                    x-text="eccState.sharedSecret.match(/.{1,64}/g)?.join(' ') || eccState.sharedSecret"></div>
                  <div class="param-label">長さ: <span x-text="(eccState.sharedSecret?.length || 0) / 2"></span> バイト</div>
                </div>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. 自分の秘密鍵d_Aと相手の公開鍵Q_Bを使用して、共有秘密鍵を計算します。<br />
                2. 楕円曲線上のスカラー倍算を使用して、S = d_A × Q_Bを計算します。これは楕円曲線上の点です。<br />
                3. この点のx座標（または座標のハッシュ値）が共有秘密鍵として使用されます。<br />
                4. 相手も同様に、自分の秘密鍵d_Bと自分の公開鍵Q_Aから同じ共有秘密鍵S = d_B × Q_A = d_A × d_B × Gを計算できます。<br />
                5. 共有秘密鍵は、対称鍵暗号の鍵として使用できます。
              </div>
            </div>
            <div x-show="eccState.error" style="color: #e74c3c; margin-top: 10px;" x-text="eccState.error"></div>
          </div>
        </div>
      </div>
    </template>

    <template x-if="selectedCrypto === 'ibe'">
      <div>
        <div class="section">
          <h2>IBE (Identity-Based Encryption) の動作</h2>
          <div class="info">
            <strong>Boneh-Franklin IBEスキーム</strong><br />
            IDベース暗号は、公開鍵がユーザーのアイデンティティ（メールアドレスなど）である暗号方式です。
          </div>

          <!-- 初期化 -->
          <div class="subsection">
            <h3>1. 初期化</h3>
            <button @click="initializeIBE()" :disabled="ibeState.initialized">WebAssemblyモジュールを初期化</button>
            <div x-show="ibeState.initialized" class="output">✅ 初期化完了</div>
            <div x-show="ibeState.showDetails.initialization && ibeState.initialized" class="detail-section">
              <div class="data-box">
                <div class="data-box-header">初期化完了</div>
                <div class="data-box-content">
                  Boneh-Franklin IBEスキームが使用可能になりました。Setup、Extract、Encrypt、Decryptの各操作を実行できます。
                </div>
              </div>
            </div>
          </div>

          <!-- マスター鍵生成 -->
          <div class="subsection">
            <h3>
              <button class="detail-toggle"
                @click="ibeState.showDetails.keyGeneration = !ibeState.showDetails.keyGeneration"
                x-show="ibeState.masterKey">
                <span x-show="!ibeState.showDetails.keyGeneration">詳細を表示</span>
                <span x-show="ibeState.showDetails.keyGeneration">詳細を隠す</span>
              </button>
              2. マスター鍵ペアの生成
            </h3>
            <button @click="generateIBEKeyPair()" :disabled="!ibeState.initialized">マスター鍵ペアを生成</button>
            <div x-show="ibeState.masterKey" class="output">
              <div>マスター鍵: <span x-text="formatBytes(ibeState.masterKey?.secret || null)"></span></div>
              <div>公開パラメータ: <span x-text="formatBytes(ibeState.publicParams?.params || null)"></span></div>
            </div>
            <div x-show="ibeState.showDetails.keyGeneration && ibeState.masterKey" class="detail-section">
              <h4>🔍 マスター鍵生成の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. ランダムなマスター秘密鍵sを生成</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    getrandomを使用して暗号学的に安全な乱数を生成<br />
                    曲線の位数で剰余を取る
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. 生成元Pを取得</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    ECP::generator() で楕円曲線の生成元を取得
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. 公開パラメータP_pubを計算</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    P_pub = sP<br />
                    （楕円曲線上のスカラー倍算）
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">4. マスター鍵s（32バイト）</div>
                  <div class="data-box-content" x-text="formatBytesReadable(ibeState.masterKey?.secret || null)"></div>
                  <div class="param-label">長さ: <span x-text="ibeState.masterKey?.secret?.length || 0"></span> バイト</div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">5. 公開パラメータP_pub</div>
                  <div class="data-box-content" x-text="formatBytesReadable(ibeState.publicParams?.params || null)">
                  </div>
                  <div class="param-label">長さ: <span x-text="ibeState.publicParams?.params?.length || 0"></span> バイト
                  </div>
                </div>
              </div>
              <div class="bytes-detail" x-show="ibeState.masterKey?.secret">
                <h4>マスター鍵のバイト詳細</h4>
                <table>
                  <thead>
                    <tr>
                      <th>位置</th>
                      <th>16進数</th>
                      <th>10進数</th>
                      <th>2進数（8ビット）</th>
                    </tr>
                  </thead>
                  <tbody>
                    <template x-for="(byte, index) in Array.from(ibeState.masterKey?.secret || [])" :key="index">
                      <tr>
                        <td x-text="index"></td>
                        <td x-text="byte.toString(16).padStart(2, '0').toUpperCase()"></td>
                        <td x-text="byte"></td>
                        <td x-text="byte.toString(2).padStart(8, '0')"></td>
                      </tr>
                    </template>
                  </tbody>
                </table>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. Setupアルゴリズム: マスター秘密鍵sをランダムに選択します。この鍵は秘密情報として厳重に管理する必要があります。<br />
                2. 公開パラメータP_pub = sPを計算します。Pは楕円曲線（BN254）の生成元です。<br />
                3. マスター鍵sは32バイト（256ビット）のBIG型として保存されます。<br />
                4. 公開パラメータP_pubは楕円曲線上の点（ECP）として、65バイトでエンコードされます。<br />
                5. この公開パラメータは、すべてのユーザーに公開され、暗号化に使用されます。
              </div>
            </div>
          </div>

          <!-- 秘密鍵抽出 -->
          <div class="subsection">
            <h3>
              <button class="detail-toggle"
                @click="ibeState.showDetails.keyExtraction = !ibeState.showDetails.keyExtraction"
                x-show="ibeState.privateKey">
                <span x-show="!ibeState.showDetails.keyExtraction">詳細を表示</span>
                <span x-show="ibeState.showDetails.keyExtraction">詳細を隠す</span>
              </button>
              3. アイデンティティから秘密鍵を抽出
            </h3>
            <label>アイデンティティ（例: user@example.com）:</label>
            <input type="text" x-model="ibeState.identity" placeholder="user@example.com" />
            <button @click="extractIBEKey()" :disabled="!ibeState.masterKey || !ibeState.identity">秘密鍵を抽出</button>
            <div x-show="ibeState.privateKey" class="output">
              秘密鍵: <span x-text="formatBytes(ibeState.privateKey?.key || null)"></span>
            </div>
            <div x-show="ibeState.showDetails.keyExtraction && ibeState.privateKey" class="detail-section">
              <h4>🔍 鍵抽出の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. アイデンティティID（文字列）</div>
                  <div class="data-box-content" x-text="ibeState.identity || '(空)'"></div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. SHA-256でハッシュ化</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    H(ID) = SHA-256(ID)<br />
                    32バイトのハッシュ値を生成
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. ハッシュからBIG型に変換</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    ハッシュ値をBIG型に変換し、<br />
                    曲線の位数で剰余を取る
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">4. ECP2の生成元で点を生成</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    H_ID = h × G2<br />
                    （G2はECP2の生成元）
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">5. 秘密鍵d_IDを計算</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    d_ID = s × H_ID<br />
                    （マスター鍵sでスカラー倍算）
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">6. 抽出された秘密鍵d_ID</div>
                  <div class="data-box-content" x-text="formatBytesReadable(ibeState.privateKey?.key || null)"></div>
                  <div class="param-label">長さ: <span x-text="ibeState.privateKey?.key?.length || 0"></span> バイト</div>
                </div>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. Extractアルゴリズム: アイデンティティID（例: メールアドレス）を入力として受け取ります。<br />
                2. IDをSHA-256でハッシュ化し、32バイトのハッシュ値を生成します。<br />
                3. ハッシュ値を楕円曲線上の点H(ID)にマッピングします。これはECP2（拡張楕円曲線上の点）です。<br />
                4. マスター秘密鍵sを使用して、秘密鍵d_ID = sH(ID)を計算します。<br />
                5. この秘密鍵d_IDは、そのアイデンティティに対応するメッセージを復号化するために使用されます。<br />
                6. 秘密鍵は130バイト（ECP2の圧縮なしエンコーディング）で保存されます。
              </div>
            </div>
          </div>

          <!-- 暗号化 -->
          <div class="subsection">
            <h3>
              <button class="detail-toggle" @click="ibeState.showDetails.encryption = !ibeState.showDetails.encryption"
                x-show="ibeState.ciphertext">
                <span x-show="!ibeState.showDetails.encryption">詳細を表示</span>
                <span x-show="ibeState.showDetails.encryption">詳細を隠す</span>
              </button>
              4. メッセージの暗号化
            </h3>
            <label>平文:</label>
            <textarea x-model="ibeState.plaintext" placeholder="暗号化するメッセージを入力"></textarea>
            <button @click="encryptIBE()"
              :disabled="!ibeState.publicParams || !ibeState.identity || !ibeState.plaintext">暗号化</button>
            <div x-show="ibeState.ciphertext" class="output">
              暗号文: <span x-text="formatBytes(ibeState.ciphertext)"></span>
            </div>
            <div x-show="ibeState.showDetails.encryption && ibeState.ciphertext" class="detail-section">
              <h4>🔍 暗号化の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 入力（文字列）</div>
                  <div class="data-box-content" x-text="ibeState.plaintext || '(空)'"></div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. バイト配列に変換</div>
                  <div class="data-box-content" x-text="formatBytesReadable(ibeState.plaintextBytes)"></div>
                  <div class="param-label">長さ: <span x-text="ibeState.plaintextBytes?.length || 0"></span> バイト</div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. ランダムなrを選択</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    getrandomを使用して暗号学的に安全な乱数rを生成<br />
                    曲線の位数で剰余を取る
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">4. U = rPを計算</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    U = r × P<br />
                    （PはECPの生成元、Uは暗号文の一部）
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">5. H(ID)を計算</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    SHA-256(ID) → BIG → ECP2上の点H_ID<br />
                    （鍵抽出と同じ処理）
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">6. ペアリング演算</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    e(H_ID, P_pub) を計算<br />
                    pair::ate() + pair::fexp()
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">7. r乗する</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    e(H_ID, P_pub)^r<br />
                    （FP12型のべき乗演算）
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">8. ハッシュ化</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    H(e(H_ID, P_pub)^r)<br />
                    FP12をバイト列に変換 → SHA-256
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">9. XOR演算</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    V = M ⊕ H(e(H_ID, P_pub)^r)<br />
                    メッセージとハッシュ値をXOR
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">10. 暗号文C = (U, V)</div>
                  <div class="data-box-content" x-text="formatBytesReadable(ibeState.ciphertext)"></div>
                  <div class="param-label">長さ: <span x-text="ibeState.ciphertext?.length || 0"></span> バイト</div>
                </div>
              </div>
              <div class="bytes-detail" x-show="ibeState.plaintextBytes">
                <h4>平文のバイト詳細</h4>
                <table>
                  <thead>
                    <tr>
                      <th>位置</th>
                      <th>16進数</th>
                      <th>10進数</th>
                      <th>ASCII</th>
                      <th>文字</th>
                    </tr>
                  </thead>
                  <tbody>
                    <template x-for="(byte, index) in Array.from(ibeState.plaintextBytes || [])" :key="index">
                      <tr>
                        <td x-text="index"></td>
                        <td x-text="byte.toString(16).padStart(2, '0').toUpperCase()"></td>
                        <td x-text="byte"></td>
                        <td x-text="byte >= 32 && byte <= 126 ? String.fromCharCode(byte) : '.'"></td>
                        <td x-text="byte >= 32 && byte <= 126 ? String.fromCharCode(byte) : '(制御文字)'"></td>
                      </tr>
                    </template>
                  </tbody>
                </table>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. Encryptアルゴリズム: 公開パラメータP_pubとアイデンティティIDを使用してメッセージを暗号化します。<br />
                2. ランダムな値rを選択し、U = rPを計算します。Uは暗号文の一部として送信されます。<br />
                3. アイデンティティIDをハッシュ化してH(ID)を計算します（鍵抽出と同じ処理）。<br />
                4. ペアリング演算e(H(ID), P_pub)を計算し、r乗します。これにより、e(H(ID), P_pub)^rが得られます。<br />
                5. ペアリング演算の結果をハッシュ化して、32バイトの鍵を生成します。<br />
                6. この鍵とメッセージをXOR演算して、Vを計算します。<br />
                7. 暗号文はC = (U, V)の形式で、Uは65バイト（ECP）、Vはメッセージと同じ長さです。
              </div>
            </div>
          </div>

          <!-- 復号化 -->
          <div class="subsection">
            <h3>
              <button class="detail-toggle" @click="ibeState.showDetails.decryption = !ibeState.showDetails.decryption"
                x-show="ibeState.decrypted">
                <span x-show="!ibeState.showDetails.decryption">詳細を表示</span>
                <span x-show="ibeState.showDetails.decryption">詳細を隠す</span>
              </button>
              5. 暗号文の復号化
            </h3>
            <button @click="decryptIBE()" :disabled="!ibeState.privateKey || !ibeState.ciphertext">復号化</button>
            <div x-show="ibeState.decrypted" class="output">
              復号化されたメッセージ: <span x-text="ibeState.decrypted"></span>
            </div>
            <div x-show="ibeState.showDetails.decryption && ibeState.decryptedBytes" class="detail-section">
              <h4>🔍 復号化の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 入力（暗号文C = (U, V)）</div>
                  <div class="data-box-content" x-text="formatBytesReadable(ibeState.ciphertext)"></div>
                  <div class="param-label">長さ: <span x-text="ibeState.ciphertext?.length || 0"></span> バイト</div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. 暗号文を解析</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    U = 暗号文の最初の65バイト（ECP）<br />
                    V = 残りのバイト（XORされたメッセージ）
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. ペアリング演算</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    e(d_ID, U) を計算<br />
                    pair::ate(d_ID, U) + pair::fexp()<br />
                    （d_IDは秘密鍵、Uは暗号文の一部）
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">4. ハッシュ化</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    H(e(d_ID, U))<br />
                    FP12をバイト列に変換 → SHA-256<br />
                    （32バイトの鍵を生成）
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">5. XOR演算</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    M = V ⊕ H(e(d_ID, U))<br />
                    Vとハッシュ値をXORしてメッセージを復元
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">6. バイト配列を文字列に変換</div>
                  <div class="data-box-content" x-text="formatBytesReadable(ibeState.decryptedBytes)"></div>
                  <div class="param-label">長さ: <span x-text="ibeState.decryptedBytes?.length || 0"></span> バイト</div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">7. 出力（文字列）</div>
                  <div class="data-box-content" x-text="ibeState.decrypted"></div>
                </div>
              </div>
              <div class="bytes-detail" x-show="ibeState.decryptedBytes">
                <h4>復号化されたバイトの詳細</h4>
                <table>
                  <thead>
                    <tr>
                      <th>位置</th>
                      <th>16進数</th>
                      <th>10進数</th>
                      <th>ASCII</th>
                      <th>文字</th>
                    </tr>
                  </thead>
                  <tbody>
                    <template x-for="(byte, index) in Array.from(ibeState.decryptedBytes || [])" :key="index">
                      <tr>
                        <td x-text="index"></td>
                        <td x-text="byte.toString(16).padStart(2, '0').toUpperCase()"></td>
                        <td x-text="byte"></td>
                        <td x-text="byte >= 32 && byte <= 126 ? String.fromCharCode(byte) : '.'"></td>
                        <td x-text="byte >= 32 && byte <= 126 ? String.fromCharCode(byte) : '(制御文字)'"></td>
                      </tr>
                    </template>
                  </tbody>
                </table>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. Decryptアルゴリズム: 秘密鍵d_IDと暗号文C = (U, V)を使用してメッセージを復号化します。<br />
                2. 暗号文を解析して、U（65バイト）とV（残りのバイト）に分離します。<br />
                3. ペアリング演算e(d_ID, U)を計算します。数学的には、e(d_ID, U) = e(sH(ID), rP) = e(H(ID), P)^(sr)となります。<br />
                4. 暗号化時にはe(H(ID), P_pub)^r = e(H(ID), sP)^r = e(H(ID), P)^(sr)を計算したので、これらは等しくなります。<br />
                5. ペアリング演算の結果をハッシュ化して、32バイトの鍵を生成します（暗号化時と同じ鍵）。<br />
                6. この鍵とVをXOR演算して、元のメッセージMを復元します。<br />
                7. バイト配列をUTF-8文字列に変換して、最終的なメッセージを取得します。
              </div>
            </div>
          </div>

          <div x-show="ibeState.error" style="color: #e74c3c; margin-top: 10px;" x-text="ibeState.error"></div>
        </div>
      </div>
    </template>

    <template x-if="selectedCrypto === 'abe'">
      <div>
        <div class="section">
          <h2>ABE (Attribute-Based Encryption) の動作</h2>
          <div class="info">
            <strong>CP-ABE (Ciphertext-Policy Attribute-Based Encryption) スキーム</strong><br />
            属性ベース暗号は、暗号文にアクセスポリシーを設定し、属性セットを持つ秘密鍵で復号化できる暗号方式です。<br />
            <span style="font-size: 0.9em; color: #e8f4f8; font-style: italic;">
              ※ 本実装は簡易版のため、属性の完全一致のみを許容しています。実際のCP-ABEでは、AND/ORなどの論理演算を含む複雑なポリシー構造をサポートできます。
            </span>
          </div>

          <!-- 初期化 -->
          <div class="subsection">
            <h3>1. 初期化</h3>
            <button @click="initializeABE()" :disabled="abeState.initialized">WebAssemblyモジュールを初期化</button>
            <div x-show="abeState.initialized" class="output">✅ 初期化完了</div>
            <div x-show="abeState.showDetails.initialization && abeState.initialized" class="detail-section">
              <div class="data-box">
                <div class="data-box-header">初期化完了</div>
                <div class="data-box-content">
                  CP-ABEスキームが使用可能になりました。Setup、KeyGen、Encrypt、Decryptの各操作を実行できます。
                </div>
              </div>
            </div>
          </div>

          <!-- マスター鍵生成 -->
          <div class="subsection">
            <h3>
              <button class="detail-toggle"
                @click="abeState.showDetails.keyGeneration = !abeState.showDetails.keyGeneration"
                x-show="abeState.masterKey">
                <span x-show="!abeState.showDetails.keyGeneration">詳細を表示</span>
                <span x-show="abeState.showDetails.keyGeneration">詳細を隠す</span>
              </button>
              2. マスター鍵ペアの生成
            </h3>
            <button @click="generateABEKeyPair()" :disabled="!abeState.initialized">マスター鍵ペアを生成</button>
            <div x-show="abeState.masterKey" class="output">
              <div>マスター鍵: <span x-text="formatBytes(abeState.masterKey?.secret || null)"></span></div>
              <div>公開パラメータ: <span x-text="formatBytes(abeState.publicParams?.params || null)"></span></div>
            </div>
            <div x-show="abeState.showDetails.keyGeneration && abeState.masterKey" class="detail-section">
              <h4>🔍 マスター鍵生成の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. ランダムなマスター秘密鍵αを生成</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    getrandomを使用して暗号学的に安全な乱数を生成<br />
                    曲線の位数で剰余を取る
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. 生成元Pを取得</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    ECP::generator() で楕円曲線の生成元を取得
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. 公開パラメータP_pubを計算</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    P_pub = αP<br />
                    （楕円曲線上のスカラー倍算）
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">4. マスター鍵α（32バイト）</div>
                  <div class="data-box-content" x-text="formatBytesReadable(abeState.masterKey?.secret || null)"></div>
                  <div class="param-label">長さ: <span x-text="abeState.masterKey?.secret?.length || 0"></span> バイト</div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">5. 公開パラメータP_pub</div>
                  <div class="data-box-content" x-text="formatBytesReadable(abeState.publicParams?.params || null)">
                  </div>
                  <div class="param-label">長さ: <span x-text="abeState.publicParams?.params?.length || 0"></span> バイト
                  </div>
                </div>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. Setupアルゴリズム: マスター秘密鍵αをランダムに選択します。この鍵は秘密情報として厳重に管理する必要があります。<br />
                2. 公開パラメータP_pub = αPを計算します。Pは楕円曲線（BN254）の生成元です。<br />
                3. マスター鍵αは32バイト（256ビット）のBIG型として保存されます。<br />
                4. 公開パラメータP_pubは楕円曲線上の点（ECP）として、65バイトでエンコードされます。<br />
                5. この公開パラメータは、すべてのユーザーに公開され、暗号化に使用されます。
              </div>
            </div>
          </div>

          <!-- 秘密鍵生成 -->
          <div class="subsection">
            <h3>
              <button class="detail-toggle"
                @click="abeState.showDetails.keyExtraction = !abeState.showDetails.keyExtraction"
                x-show="abeState.privateKey">
                <span x-show="!abeState.showDetails.keyExtraction">詳細を表示</span>
                <span x-show="abeState.showDetails.keyExtraction">詳細を隠す</span>
              </button>
              3. 属性セットから秘密鍵を生成
            </h3>
            <label>属性を追加（1つずつ、またはカンマ区切りで複数、例: A または A, B, C）:</label>
            <div style="display: flex; gap: 10px; margin-bottom: 10px;">
              <input type="text" x-model="abeState.attributeInput" placeholder="属性名を入力（例: A または A, B, C）"
                style="flex: 1;" />
              <button @click="addAttribute()">属性を追加</button>
            </div>
            <div x-show="abeState.attributes.length > 0" style="margin-bottom: 10px;">
              <strong>属性セット:</strong>
              <div style="display: flex; flex-wrap: wrap; gap: 5px; margin-top: 5px;">
                <template x-for="(attr, index) in abeState.attributes" :key="index">
                  <span
                    style="background: #3498db; color: white; padding: 5px 10px; border-radius: 4px; display: inline-flex; align-items: center; gap: 5px;">
                    <span x-text="attr"></span>
                    <button @click="removeAttribute(index)"
                      style="background: rgba(255,255,255,0.3); border: none; color: white; cursor: pointer; padding: 2px 5px; border-radius: 2px;">×</button>
                  </span>
                </template>
              </div>
            </div>
            <button @click="extractABEKey()"
              :disabled="!abeState.masterKey || abeState.attributes.length === 0">秘密鍵を生成</button>
            <div x-show="abeState.privateKey" class="output">
              秘密鍵: <span x-text="formatBytes(abeState.privateKey?.key || null)"></span><br />
              属性: <span x-text="abeState.privateKey?.attributes?.join(', ') || ''"></span>
            </div>
            <div x-show="abeState.showDetails.keyExtraction && abeState.privateKey" class="detail-section">
              <h4>🔍 鍵生成の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 属性セット</div>
                  <div class="data-box-content" x-text="abeState.attributes.join(', ') || '(空)'"></div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. 各属性をハッシュ化</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    各属性attrに対して:<br />
                    H(attr) = SHA-256(attr)<br />
                    ECP2上の点に変換
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. 秘密鍵コンポーネントを計算</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    各属性に対して:<br />
                    key_comp = α × H(attr)<br />
                    （マスター鍵αでスカラー倍算）
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">4. 生成された秘密鍵</div>
                  <div class="data-box-content" x-text="formatBytesReadable(abeState.privateKey?.key || null)"></div>
                  <div class="param-label">長さ: <span x-text="abeState.privateKey?.key?.length || 0"></span> バイト</div>
                </div>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. KeyGenアルゴリズム: 属性セットを受け取ります。<br />
                2. 各属性をSHA-256でハッシュ化し、ECP2上の点H(attr)にマッピングします。<br />
                3. マスター秘密鍵αを使用して、各属性に対応する秘密鍵コンポーネントkey_comp = αH(attr)を計算します。<br />
                4. すべての鍵コンポーネントを結合して、属性セットに対応する秘密鍵を生成します。<br />
                5. この秘密鍵は、ポリシーを満たす属性セットを持つ場合にのみ、暗号文を復号化できます。
              </div>
            </div>
          </div>

          <!-- 暗号化 -->
          <div class="subsection">
            <h3>
              <button class="detail-toggle" @click="abeState.showDetails.encryption = !abeState.showDetails.encryption"
                x-show="abeState.ciphertext">
                <span x-show="!abeState.showDetails.encryption">詳細を表示</span>
                <span x-show="abeState.showDetails.encryption">詳細を隠す</span>
              </button>
              4. メッセージの暗号化
            </h3>
            <label>アクセスポリシー（カンマ区切りの属性、例: A,B,C）:</label>
            <div style="font-size: 0.85em; color: #555; margin-bottom: 5px; font-style: italic;">
              ※ 簡易実装のため、属性の完全一致のみをサポートしています。すべての属性が一致する必要があります。
            </div>
            <input type="text" x-model="abeState.policy" placeholder="A,B,C" />
            <label>平文:</label>
            <textarea x-model="abeState.plaintext" placeholder="暗号化するメッセージを入力"></textarea>
            <button @click="encryptABE()"
              :disabled="!abeState.publicParams || !abeState.policy || !abeState.plaintext">暗号化</button>
            <div x-show="abeState.ciphertext" class="output">
              暗号文: <span x-text="formatBytes(abeState.ciphertext)"></span>
            </div>
            <div x-show="abeState.showDetails.encryption && abeState.ciphertext" class="detail-section">
              <h4>🔍 暗号化の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. ポリシー（属性リスト）</div>
                  <div class="data-box-content" x-text="abeState.policy || '(空)'"></div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. ランダムなsを選択</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    getrandomを使用して暗号学的に安全な乱数を生成
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. C0 = sPを計算</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    C0は暗号文の一部<br />
                    Pは生成元
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">4. 各属性の暗号文コンポーネント</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    各属性attrに対して:<br />
                    C_attr = s × H(attr)
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">5. メッセージの暗号化</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    ペアリング演算の結果をハッシュ化<br />
                    V = M ⊕ H(e(P_pub, H(attr))^s)
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">6. 暗号文（C0 || V || C_attrs）</div>
                  <div class="data-box-content" x-text="formatBytesReadable(abeState.ciphertext)"></div>
                  <div class="param-label">長さ: <span x-text="abeState.ciphertext?.length || 0"></span> バイト</div>
                </div>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. Encryptアルゴリズム: アクセスポリシー（属性のリスト）とメッセージを受け取ります。<br />
                2. ランダムなsを選択し、C0 = sPを計算します。<br />
                3. 各属性に対して、暗号文コンポーネントC_attr = sH(attr)を計算します。<br />
                4. ペアリング演算e(P_pub, H(attr))^sを計算し、その結果をハッシュ化して鍵を生成します。<br />
                5. この鍵とメッセージをXOR演算して、暗号文Vを生成します。<br />
                6. 最終的な暗号文は、C0、V、およびすべての属性コンポーネントC_attrsを結合したものです。
              </div>
            </div>
          </div>

          <!-- 復号化 -->
          <div class="subsection">
            <h3>
              <button class="detail-toggle" @click="abeState.showDetails.decryption = !abeState.showDetails.decryption"
                x-show="abeState.decryptionSucceeded !== null">
                <span x-show="!abeState.showDetails.decryption">詳細を表示</span>
                <span x-show="abeState.showDetails.decryption">詳細を隠す</span>
              </button>
              5. 暗号文の復号化
            </h3>
            <button @click="decryptABE()" :disabled="!abeState.privateKey || !abeState.ciphertext">復号化</button>
            <div x-show="abeState.decryptionSucceeded !== null" style="margin-top: 15px;">
              <div class="data-box"
                :style="abeState.decryptionSucceeded ? 'border-left-color: #2ecc71;' : 'border-left-color: #e74c3c;'">
                <div class="data-box-label">復号化結果</div>
                <div class="data-box-content">
                  <span x-show="abeState.decryptionSucceeded" style="color: #2ecc71; font-weight: bold">
                    ✓ 復号化成功
                  </span>
                  <span x-show="!abeState.decryptionSucceeded" style="color: #e74c3c; font-weight: bold">
                    ✗ 復号化失敗（属性が一致しません）
                  </span>
                </div>
              </div>
            </div>
            <div x-show="abeState.decrypted && abeState.decryptionSucceeded" class="output">
              復号化されたメッセージ: <span x-text="abeState.decrypted"></span>
            </div>
            <div x-show="abeState.showDetails.decryption && abeState.decryptionSucceeded && abeState.decrypted"
              class="detail-section">
              <h4>🔍 復号化の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 暗号文を解析</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    C0、V、C_attrsを抽出<br />
                    （C0 || V || C_attrsの形式）
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. 秘密鍵コンポーネントを抽出</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    属性に対応する鍵コンポーネントを取得
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. ペアリング演算を計算</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    e(key_comp, C0)を計算<br />
                    暗号化時の鍵と一致する
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">4. 鍵を生成</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    ペアリング演算の結果をハッシュ化<br />
                    H(e(key_comp, C0))
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">5. メッセージを復元</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    M = V ⊕ H(e(key_comp, C0))<br />
                    XOR演算で元のメッセージを取得
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">6. 復号化されたメッセージ</div>
                  <div class="data-box-content" x-text="abeState.decrypted || '(空)'"></div>
                </div>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. Decryptアルゴリズム: 秘密鍵と暗号文を受け取ります。<br />
                2. 暗号文から属性数を読み取り、秘密鍵の属性数と比較します。<br />
                3. 属性数が一致しない場合、復号化は失敗します（属性が異なるため）。<br />
                4. 属性数が一致する場合、暗号文からC0、V、C_attrsを抽出します。<br />
                5. 秘密鍵から属性に対応する鍵コンポーネントを取得します。<br />
                6. ペアリング演算e(key_comp, C0)を計算します。数学的には、e(αH(attr), sP) = e(H(attr), P)^(αs)となります。<br />
                7. 暗号化時にはe(P_pub, H(attr))^s = e(αP, H(attr))^s = e(H(attr), P)^(αs)を計算したので、これらは等しくなります。<br />
                8. ペアリング演算の結果をハッシュ化して、32バイトの鍵を生成します（暗号化時と同じ鍵）。<br />
                9. この鍵とVをXOR演算して、元のメッセージMを復元します。<br />
                10. バイト配列をUTF-8文字列に変換して、最終的なメッセージを取得します。
              </div>
            </div>
            <div
              x-show="abeState.showDetails.decryption && !abeState.decryptionSucceeded && abeState.decryptionSucceeded !== null"
              class="detail-section">
              <h4>🔍 復号化失敗の理由</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 暗号文の属性数を確認</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    暗号文の先頭から属性数を読み取る
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. 秘密鍵の属性数を確認</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    秘密鍵に含まれる属性数を確認
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box" style="border-left-color: #e74c3c;">
                  <div class="data-box-label">3. 属性数の不一致を検出</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    暗号化時に使用した属性と<br />
                    鍵生成時に使用した属性が異なるため、<br />
                    復号化できません
                  </div>
                </div>
              </div>
              <div
                style="margin-top: 15px; padding: 10px; background: #f8d7da; border-radius: 4px; font-size: 12px; color: #721c24;">
                <strong>復号化失敗の理由:</strong><br />
                CP-ABEでは、暗号化時に使用した属性と鍵生成時に使用した属性が一致する必要があります。<br />
                属性が異なる場合、暗号文の構造と秘密鍵の構造が一致しないため、復号化できません。<br />
                これは、属性ベース暗号のセキュリティ特性の一部です。
              </div>
            </div>
          </div>

          <div x-show="abeState.error" style="color: #e74c3c; margin-top: 10px;" x-text="abeState.error"></div>
        </div>
      </div>
    </template>

    <!-- Hash Functions - SHA-256 -->
    <template x-if="selectedCrypto === 'hash-sha256'">
      <div>
        <div class="section">
          <h2>SHA-256 の動作</h2>
          <div class="info">
            <strong>概要:</strong><br />
            SHA-256は、任意の長さのデータから256ビット（32バイト）のハッシュ値を生成する一方向関数です。<br />
            主な用途: データの整合性検証、パスワード保存、デジタル署名、メッセージ認証など<br />
            <br />
            <strong>特徴:</strong><br />
            • NIST標準の暗号学的ハッシュ関数<br />
            • Merkle-Damgård構造<br />
            • 256ビット（32バイト）の固定長出力<br />
            • 広く使用されている実績のあるアルゴリズム
          </div>

          <!-- Input Section -->
          <div class="step">
            <div class="step-title">
              <span class="step-number">1</span>
              入力データ
              <button class="detail-toggle" @click="hashState.showDetails.input = !hashState.showDetails.input"
                x-show="hashState.inputText">
                <span x-show="!hashState.showDetails.input">詳細を表示</span>
                <span x-show="hashState.showDetails.input">詳細を隠す</span>
              </button>
            </div>

            <div class="param-group">
              <label for="hash-input-sha256">入力テキスト:</label>
              <textarea id="hash-input-sha256" x-model="hashState.inputText" rows="4"
                placeholder="ハッシュ値を計算したいテキストを入力してください"
                @input="hashState.error = ''; hashState.hash = null; hashState.comparisonResults = {};"></textarea>
            </div>

            <div x-show="hashState.inputText" class="output">
              <strong>入力サイズ:</strong>
              <span x-text="new TextEncoder().encode(hashState.inputText).length"></span> バイト
              (<span x-text="hashState.inputText.length"></span> 文字)
            </div>

            <div x-show="hashState.showDetails.input && hashState.inputText" class="detail-section">
              <h4>🔍 入力データの詳細</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. テキスト入力</div>
                  <div class="data-box-content" style="max-height: 100px; overflow: auto;" x-text="hashState.inputText">
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. UTF-8エンコード</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    TextEncoderを使用してバイト配列に変換
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. バイト配列</div>
                  <div class="data-box-content"
                    style="font-family: monospace; word-break: break-all; max-height: 100px; overflow: auto;">
                    <template
                      x-for="(byte, index) in Array.from(new TextEncoder().encode(hashState.inputText)).slice(0, 64)"
                      :key="index">
                      <span x-text="byte.toString(16).padStart(2, '0') + ' '"></span>
                    </template>
                    <span x-show="new TextEncoder().encode(hashState.inputText).length > 64">...</span>
                  </div>
                  <div class="param-label">
                    長さ: <span x-text="new TextEncoder().encode(hashState.inputText).length"></span> バイト
                  </div>
                </div>
              </div>
              <div class="bytes-detail" x-show="new TextEncoder().encode(hashState.inputText).length <= 32">
                <h4>入力データのバイト詳細 (最初の32バイト)</h4>
                <table>
                  <thead>
                    <tr>
                      <th>位置</th>
                      <th>16進数</th>
                      <th>10進数</th>
                      <th>2進数（8ビット）</th>
                      <th>ASCII</th>
                    </tr>
                  </thead>
                  <tbody>
                    <template
                      x-for="(byte, index) in Array.from(new TextEncoder().encode(hashState.inputText)).slice(0, 32)"
                      :key="index">
                      <tr>
                        <td x-text="index"></td>
                        <td x-text="byte.toString(16).padStart(2, '0').toUpperCase()"></td>
                        <td x-text="byte"></td>
                        <td x-text="byte.toString(2).padStart(8, '0')"></td>
                        <td x-text="byte >= 32 && byte < 127 ? String.fromCharCode(byte) : '·'"></td>
                      </tr>
                    </template>
                  </tbody>
                </table>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. 入力されたテキストはUTF-8エンコーディングでバイト配列に変換されます。<br />
                2. 各文字は1〜4バイトで表現されます（ASCIIは1バイト、日本語などは3バイト）。<br />
                3. このバイト配列がハッシュ関数への入力となります。<br />
                4. ハッシュ関数は任意の長さの入力を受け付け、固定長の出力を生成します。
              </div>
            </div>
          </div>

          <!-- Hash Computation -->
          <div class="step" x-init="hashState.selectedAlgorithm = 'sha256'; hashState.comparisonMode = false;">
            <div class="step-title">
              <span class="step-number">2</span>
              ハッシュ値の計算
              <button class="detail-toggle"
                @click="hashState.showDetails.processing = !hashState.showDetails.processing" x-show="hashState.hash">
                <span x-show="!hashState.showDetails.processing">詳細を表示</span>
                <span x-show="hashState.showDetails.processing">詳細を隠す</span>
              </button>
            </div>
            <button @click="computeHash()" :disabled="!hashState.inputText">
              ハッシュ値を計算
            </button>

            <!-- Single Algorithm Result -->
            <div x-show="hashState.hash" class="output">
              <strong>計算時間:</strong> <span x-text="hashState.processingTime.toFixed(3)"></span> ミリ秒<br />
              <strong>出力サイズ:</strong> <span x-text="(hashState.hash || []).length"></span> バイト
              (<span x-text="(hashState.hash || []).length * 8"></span> ビット)
            </div>

            <div x-show="hashState.showDetails.processing && hashState.hash" class="detail-section">
              <h4>🔍 ハッシュ計算の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 入力データ</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    UTF-8エンコードされたバイト配列
                  </div>
                  <div class="param-label">
                    <span x-text="new TextEncoder().encode(hashState.inputText).length"></span> バイト
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. SHA-256でハッシュ化</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    SHA-256<br />
                    一方向関数による変換
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. ハッシュ値</div>
                  <div class="data-box-content" style="font-family: monospace; word-break: break-all; font-size: 10px;">
                    <template x-for="(byte, index) in Array.from(hashState.hash || []).slice(0, 16)" :key="index">
                      <span x-text="byte.toString(16).padStart(2, '0') + ' '"></span>
                    </template>
                    <span x-show="(hashState.hash || []).length > 16">...</span>
                  </div>
                  <div class="param-label">
                    <span x-text="(hashState.hash || []).length"></span> バイト（固定長）
                  </div>
                </div>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. ハッシュ関数は、任意の長さの入力データから固定長の出力（ハッシュ値）を生成します。<br />
                2. 一方向性により、ハッシュ値から元のデータを復元することは計算量的に困難です。<br />
                3. 入力の1ビットの変化でも、出力の約半分のビットが変化します（雪崩効果）。<br />
                4. 同じ入力に対しては、常に同じハッシュ値が生成されます（決定性）。
              </div>
            </div>
          </div>

          <!-- Output Section -->
          <div x-show="hashState.hash" class="step">
            <div class="step-title">
              <span class="step-number">3</span>
              ハッシュ値 (出力)
              <button class="detail-toggle" @click="hashState.showDetails.output = !hashState.showDetails.output"
                x-show="hashState.hash">
                <span x-show="!hashState.showDetails.output">詳細を表示</span>
                <span x-show="hashState.showDetails.output">詳細を隠す</span>
              </button>
            </div>

            <!-- Single Algorithm Output -->
            <div x-show="hashState.hash" class="output">
              <strong>ハッシュ値 (16進数):</strong><br />
              <span style="word-break: break-all; font-family: monospace;"
                x-text="Array.from(hashState.hash || []).map(b => b.toString(16).padStart(2, '0')).join('')"></span><br /><br />
              <strong>ハッシュ値 (Base64):</strong><br />
              <span style="word-break: break-all; font-family: monospace;"
                x-text="btoa(String.fromCharCode(...Array.from(hashState.hash || [])))"></span><br /><br />
              <strong>出力サイズ:</strong> <span x-text="(hashState.hash || []).length"></span> バイト
              (<span x-text="(hashState.hash || []).length * 8"></span> ビット)
            </div>

            <div x-show="hashState.showDetails.output && hashState.hash" class="detail-section">
              <h4>🔍 ハッシュ値の詳細</h4>

              <!-- Single Algorithm Details -->
              <div>
                <div class="data-flow">
                  <div class="data-box">
                    <div class="data-box-label">ハッシュ値 (16進数)</div>
                    <div class="data-box-content"
                      style="font-family: monospace; word-break: break-all; font-size: 10px;">
                      <span
                        x-text="Array.from(hashState.hash || []).map(b => b.toString(16).padStart(2, '0')).join('')"></span>
                    </div>
                    <div class="param-label">
                      長さ: <span x-text="(hashState.hash || []).length"></span> バイト
                      (<span x-text="(hashState.hash || []).length * 8"></span> ビット)
                    </div>
                  </div>
                </div>

                <div style="margin-top: 15px;">
                  <strong>ハッシュ値 (Base64):</strong>
                  <div class="output"
                    style="margin-top: 5px; word-break: break-all; font-family: monospace; font-size: 0.9em;">
                    <span x-text="btoa(String.fromCharCode(...Array.from(hashState.hash || [])))"></span>
                  </div>
                </div>

                <!-- Byte Table Display -->
                <div class="bytes-detail" style="margin-top: 15px;">
                  <h4>ハッシュ値のバイト詳細</h4>
                  <table>
                    <thead>
                      <tr>
                        <th>位置</th>
                        <th>16進数</th>
                        <th>10進数</th>
                        <th>2進数（8ビット）</th>
                      </tr>
                    </thead>
                    <tbody>
                      <template x-for="(byte, index) in Array.from(hashState.hash || [])" :key="index">
                        <tr>
                          <td x-text="index"></td>
                          <td x-text="byte.toString(16).padStart(2, '0').toUpperCase()"></td>
                          <td x-text="byte"></td>
                          <td x-text="byte.toString(2).padStart(8, '0')"></td>
                        </tr>
                      </template>
                    </tbody>
                  </table>
                </div>

                <div style="margin-top: 15px;">
                  <strong>バイト単位表示:</strong>
                  <div class="byte-display" style="margin-top: 5px;">
                    <template x-for="(byte, index) in Array.from(hashState.hash || [])" :key="index">
                      <span class="byte" x-text="byte.toString(16).padStart(2, '0')"
                        :title="'Byte ' + index + ': 0x' + byte.toString(16).padStart(2, '0') + ' (' + byte + ')'"></span>
                    </template>
                  </div>
                </div>
              </div>

              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. ハッシュ関数は、任意の長さの入力データから固定長の出力（ハッシュ値）を生成します。<br />
                2. ハッシュ値は16進数やBase64形式で表示できます。<br />
                3. 同じ入力に対しては、常に同じハッシュ値が生成されます（決定性）。<br />
                4. ハッシュ値から元のデータを復元することは計算量的に困難です（一方向性）。
              </div>
            </div>
          </div>

          <!-- Hash Function Properties -->
          <div class="section">
            <h3>ハッシュ関数の性質</h3>
            <div class="info">
              <strong>暗号学的ハッシュ関数の要件:</strong><br />
              1. <strong>一方向性</strong>: ハッシュ値から元のデータを復元することが計算量的に困難<br />
              2. <strong>決定性</strong>: 同じ入力に対しては常に同じハッシュ値を生成<br />
              3. <strong>固定長出力</strong>: 入力の長さに関わらず、常に固定長の出力を生成<br />
              4. <strong>衝突困難性</strong>: 異なる入力から同じハッシュ値を生成することが困難<br />
              5. <strong>雪崩効果</strong>: 入力の1ビットの変化が出力の約半分のビットを変化させる<br />
              <br />
              <strong>構造:</strong><br />
              • <strong>SHA-256</strong>: Merkle-Damgård構造
            </div>
          </div>

          <div x-show="hashState.error" style="color: #e74c3c; margin-top: 10px;" x-text="hashState.error"></div>
        </div>
      </div>
    </template>

    <!-- Hash Functions - SHA-512 -->
    <template x-if="selectedCrypto === 'hash-sha512'">
      <div>
        <div class="section">
          <h2>SHA-512 の動作</h2>
          <div class="info">
            <strong>概要:</strong><br />
            SHA-512は、任意の長さのデータから512ビット（64バイト）のハッシュ値を生成する一方向関数です。<br />
            主な用途: データの整合性検証、パスワード保存、デジタル署名、メッセージ認証など<br />
            <br />
            <strong>特徴:</strong><br />
            • NIST標準の暗号学的ハッシュ関数<br />
            • Merkle-Damgård構造<br />
            • 512ビット（64バイト）の固定長出力<br />
            • 広く使用されている実績のあるアルゴリズム
          </div>

          <!-- Input Section -->
          <div class="step">
            <div class="step-title">
              <span class="step-number">1</span>
              入力データ
              <button class="detail-toggle" @click="hashState.showDetails.input = !hashState.showDetails.input"
                x-show="hashState.inputText">
                <span x-show="!hashState.showDetails.input">詳細を表示</span>
                <span x-show="hashState.showDetails.input">詳細を隠す</span>
              </button>
            </div>

            <div class="param-group">
              <label for="hash-input-sha512">入力テキスト:</label>
              <textarea id="hash-input-sha512" x-model="hashState.inputText" rows="4"
                placeholder="ハッシュ値を計算したいテキストを入力してください"
                @input="hashState.error = ''; hashState.hash = null; hashState.comparisonResults = {};"></textarea>
            </div>

            <div x-show="hashState.inputText" class="output">
              <strong>入力サイズ:</strong>
              <span x-text="new TextEncoder().encode(hashState.inputText).length"></span> バイト
              (<span x-text="hashState.inputText.length"></span> 文字)
            </div>

            <div x-show="hashState.showDetails.input && hashState.inputText" class="detail-section">
              <h4>🔍 入力データの詳細</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. テキスト入力</div>
                  <div class="data-box-content" style="max-height: 100px; overflow: auto;" x-text="hashState.inputText">
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. UTF-8エンコード</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    TextEncoderを使用してバイト配列に変換
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. バイト配列</div>
                  <div class="data-box-content"
                    style="font-family: monospace; word-break: break-all; max-height: 100px; overflow: auto;">
                    <template
                      x-for="(byte, index) in Array.from(new TextEncoder().encode(hashState.inputText)).slice(0, 64)"
                      :key="index">
                      <span x-text="byte.toString(16).padStart(2, '0') + ' '"></span>
                    </template>
                    <span x-show="new TextEncoder().encode(hashState.inputText).length > 64">...</span>
                  </div>
                  <div class="param-label">
                    長さ: <span x-text="new TextEncoder().encode(hashState.inputText).length"></span> バイト
                  </div>
                </div>
              </div>
              <div class="bytes-detail" x-show="new TextEncoder().encode(hashState.inputText).length <= 32">
                <h4>入力データのバイト詳細 (最初の32バイト)</h4>
                <table>
                  <thead>
                    <tr>
                      <th>位置</th>
                      <th>16進数</th>
                      <th>10進数</th>
                      <th>2進数（8ビット）</th>
                      <th>ASCII</th>
                    </tr>
                  </thead>
                  <tbody>
                    <template
                      x-for="(byte, index) in Array.from(new TextEncoder().encode(hashState.inputText)).slice(0, 32)"
                      :key="index">
                      <tr>
                        <td x-text="index"></td>
                        <td x-text="byte.toString(16).padStart(2, '0').toUpperCase()"></td>
                        <td x-text="byte"></td>
                        <td x-text="byte.toString(2).padStart(8, '0')"></td>
                        <td x-text="byte >= 32 && byte < 127 ? String.fromCharCode(byte) : '·'"></td>
                      </tr>
                    </template>
                  </tbody>
                </table>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. 入力されたテキストはUTF-8エンコーディングでバイト配列に変換されます。<br />
                2. 各文字は1〜4バイトで表現されます（ASCIIは1バイト、日本語などは3バイト）。<br />
                3. このバイト配列がハッシュ関数への入力となります。<br />
                4. ハッシュ関数は任意の長さの入力を受け付け、固定長の出力を生成します。
              </div>
            </div>
          </div>

          <!-- Hash Computation -->
          <div class="step" x-init="hashState.selectedAlgorithm = 'sha512'; hashState.comparisonMode = false;">
            <div class="step-title">
              <span class="step-number">2</span>
              ハッシュ値の計算
              <button class="detail-toggle"
                @click="hashState.showDetails.processing = !hashState.showDetails.processing" x-show="hashState.hash">
                <span x-show="!hashState.showDetails.processing">詳細を表示</span>
                <span x-show="hashState.showDetails.processing">詳細を隠す</span>
              </button>
            </div>
            <button @click="computeHash()" :disabled="!hashState.inputText">
              ハッシュ値を計算
            </button>

            <!-- Single Algorithm Result -->
            <div x-show="hashState.hash" class="output">
              <strong>計算時間:</strong> <span x-text="hashState.processingTime.toFixed(3)"></span> ミリ秒<br />
              <strong>出力サイズ:</strong> <span x-text="(hashState.hash || []).length"></span> バイト
              (<span x-text="(hashState.hash || []).length * 8"></span> ビット)
            </div>

            <div x-show="hashState.showDetails.processing && hashState.hash" class="detail-section">
              <h4>🔍 ハッシュ計算の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 入力データ</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    UTF-8エンコードされたバイト配列
                  </div>
                  <div class="param-label">
                    <span x-text="new TextEncoder().encode(hashState.inputText).length"></span> バイト
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. SHA-512でハッシュ化</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    SHA-512<br />
                    一方向関数による変換
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. ハッシュ値</div>
                  <div class="data-box-content" style="font-family: monospace; word-break: break-all; font-size: 10px;">
                    <template x-for="(byte, index) in Array.from(hashState.hash || []).slice(0, 16)" :key="index">
                      <span x-text="byte.toString(16).padStart(2, '0') + ' '"></span>
                    </template>
                    <span x-show="(hashState.hash || []).length > 16">...</span>
                  </div>
                  <div class="param-label">
                    <span x-text="(hashState.hash || []).length"></span> バイト（固定長）
                  </div>
                </div>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. ハッシュ関数は、任意の長さの入力データから固定長（512ビット/64バイト）の出力（ハッシュ値）を生成します。<br />
                2. 一方向性により、ハッシュ値から元のデータを復元することは計算量的に困難です。<br />
                3. 入力の1ビットの変化でも、出力の約半分のビットが変化します（雪崩効果）。<br />
                4. 同じ入力に対しては、常に同じハッシュ値が生成されます（決定性）。
              </div>
            </div>
          </div>

          <!-- Output Section -->
          <div x-show="hashState.hash" class="step">
            <div class="step-title">
              <span class="step-number">3</span>
              ハッシュ値 (出力)
              <button class="detail-toggle" @click="hashState.showDetails.output = !hashState.showDetails.output"
                x-show="hashState.hash">
                <span x-show="!hashState.showDetails.output">詳細を表示</span>
                <span x-show="hashState.showDetails.output">詳細を隠す</span>
              </button>
            </div>

            <!-- Single Algorithm Output -->
            <div x-show="hashState.hash" class="output">
              <strong>ハッシュ値 (16進数):</strong><br />
              <span style="word-break: break-all; font-family: monospace;"
                x-text="Array.from(hashState.hash || []).map(b => b.toString(16).padStart(2, '0')).join('')"></span><br /><br />
              <strong>ハッシュ値 (Base64):</strong><br />
              <span style="word-break: break-all; font-family: monospace;"
                x-text="btoa(String.fromCharCode(...Array.from(hashState.hash || [])))"></span><br /><br />
              <strong>出力サイズ:</strong> <span x-text="(hashState.hash || []).length"></span> バイト
              (<span x-text="(hashState.hash || []).length * 8"></span> ビット)
            </div>

            <div x-show="hashState.showDetails.output && hashState.hash" class="detail-section">
              <h4>🔍 ハッシュ値の詳細</h4>

              <!-- Single Algorithm Details -->
              <div>
                <div class="data-flow">
                  <div class="data-box">
                    <div class="data-box-label">ハッシュ値 (16進数)</div>
                    <div class="data-box-content"
                      style="font-family: monospace; word-break: break-all; font-size: 10px;">
                      <span
                        x-text="Array.from(hashState.hash || []).map(b => b.toString(16).padStart(2, '0')).join('')"></span>
                    </div>
                    <div class="param-label">
                      長さ: <span x-text="(hashState.hash || []).length"></span> バイト
                      (<span x-text="(hashState.hash || []).length * 8"></span> ビット)
                    </div>
                  </div>
                </div>

                <div style="margin-top: 15px;">
                  <strong>ハッシュ値 (Base64):</strong>
                  <div class="output"
                    style="margin-top: 5px; word-break: break-all; font-family: monospace; font-size: 0.9em;">
                    <span x-text="btoa(String.fromCharCode(...Array.from(hashState.hash || [])))"></span>
                  </div>
                </div>

                <!-- Byte Table Display -->
                <div class="bytes-detail" style="margin-top: 15px;">
                  <h4>ハッシュ値のバイト詳細</h4>
                  <table>
                    <thead>
                      <tr>
                        <th>位置</th>
                        <th>16進数</th>
                        <th>10進数</th>
                        <th>2進数（8ビット）</th>
                      </tr>
                    </thead>
                    <tbody>
                      <template x-for="(byte, index) in Array.from(hashState.hash || [])" :key="index">
                        <tr>
                          <td x-text="index"></td>
                          <td x-text="byte.toString(16).padStart(2, '0').toUpperCase()"></td>
                          <td x-text="byte"></td>
                          <td x-text="byte.toString(2).padStart(8, '0')"></td>
                        </tr>
                      </template>
                    </tbody>
                  </table>
                </div>

                <div style="margin-top: 15px;">
                  <strong>バイト単位表示:</strong>
                  <div class="byte-display" style="margin-top: 5px;">
                    <template x-for="(byte, index) in Array.from(hashState.hash || [])" :key="index">
                      <span class="byte" x-text="byte.toString(16).padStart(2, '0')"
                        :title="'Byte ' + index + ': 0x' + byte.toString(16).padStart(2, '0') + ' (' + byte + ')'"></span>
                    </template>
                  </div>
                </div>
              </div>

              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. ハッシュ関数は、任意の長さの入力データから固定長（512ビット/64バイト）の出力（ハッシュ値）を生成します。<br />
                2. ハッシュ値は16進数やBase64形式で表示できます。<br />
                3. 同じ入力に対しては、常に同じハッシュ値が生成されます（決定性）。<br />
                4. ハッシュ値から元のデータを復元することは計算量的に困難です（一方向性）。
              </div>
            </div>
          </div>

          <!-- Hash Function Properties -->
          <div class="section">
            <h3>ハッシュ関数の性質</h3>
            <div class="info">
              <strong>暗号学的ハッシュ関数の要件:</strong><br />
              1. <strong>一方向性</strong>: ハッシュ値から元のデータを復元することが計算量的に困難<br />
              2. <strong>決定性</strong>: 同じ入力に対しては常に同じハッシュ値を生成<br />
              3. <strong>固定長出力</strong>: 入力の長さに関わらず、常に固定長（512ビット/64バイト）の出力を生成<br />
              4. <strong>衝突困難性</strong>: 異なる入力から同じハッシュ値を生成することが困難<br />
              5. <strong>雪崩効果</strong>: 入力の1ビットの変化が出力の約半分のビットを変化させる<br />
              <br />
              <strong>構造:</strong><br />
              • <strong>SHA-512</strong>: Merkle-Damgård構造
            </div>
          </div>

          <div x-show="hashState.error" style="color: #e74c3c; margin-top: 10px;" x-text="hashState.error"></div>
        </div>
      </div>
    </template>

    <!-- Hash Functions - Comparison Mode -->
    <template x-if="selectedCrypto === 'hash-compare'">
      <div>
        <div class="section">
          <h2>全アルゴリズム比較計算</h2>
          <div class="info">
            <strong>概要:</strong><br />
            複数のハッシュアルゴリズムを同時に実行し、性能を比較できます。<br />
            比較対象: SHA-256, SHA-512, SHA-3-256, BLAKE2b, BLAKE3<br />
            <br />
            <strong>比較項目:</strong><br />
            • 処理時間（ミリ秒）<br />
            • 出力サイズ（ビット）<br />
            • ハッシュ値（16進数）
          </div>

          <!-- Input Section -->
          <div class="step">
            <div class="step-title">
              <span class="step-number">1</span>
              入力データ
              <button class="detail-toggle" @click="hashState.showDetails.input = !hashState.showDetails.input"
                x-show="hashState.inputText">
                <span x-show="!hashState.showDetails.input">詳細を表示</span>
                <span x-show="hashState.showDetails.input">詳細を隠す</span>
              </button>
            </div>

            <div class="param-group">
              <label for="hash-input-compare">入力テキスト:</label>
              <textarea id="hash-input-compare" x-model="hashState.inputText" rows="4"
                placeholder="ハッシュ値を計算したいテキストを入力してください"
                @input="hashState.error = ''; hashState.comparisonResults = {};"></textarea>
            </div>

            <div x-show="hashState.inputText" class="output">
              <strong>入力サイズ:</strong>
              <span x-text="new TextEncoder().encode(hashState.inputText).length"></span> バイト
              (<span x-text="hashState.inputText.length"></span> 文字)
            </div>

            <div x-show="hashState.showDetails.input && hashState.inputText" class="detail-section">
              <h4>🔍 入力データの詳細</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. テキスト入力</div>
                  <div class="data-box-content" style="max-height: 100px; overflow: auto;" x-text="hashState.inputText">
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. UTF-8エンコード</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    TextEncoderを使用してバイト配列に変換
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. バイト配列</div>
                  <div class="data-box-content"
                    style="font-family: monospace; word-break: break-all; max-height: 100px; overflow: auto;">
                    <template
                      x-for="(byte, index) in Array.from(new TextEncoder().encode(hashState.inputText)).slice(0, 64)"
                      :key="index">
                      <span x-text="byte.toString(16).padStart(2, '0') + ' '"></span>
                    </template>
                    <span x-show="new TextEncoder().encode(hashState.inputText).length > 64">...</span>
                  </div>
                  <div class="param-label">
                    長さ: <span x-text="new TextEncoder().encode(hashState.inputText).length"></span> バイト
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Comparison Computation -->
          <div class="step" x-init="hashState.comparisonMode = true;">
            <div class="step-title">
              <span class="step-number">2</span>
              全アルゴリズムで計算
              <button class="detail-toggle"
                @click="hashState.showDetails.processing = !hashState.showDetails.processing"
                x-show="Object.keys(hashState.comparisonResults).length > 0">
                <span x-show="!hashState.showDetails.processing">詳細を表示</span>
                <span x-show="hashState.showDetails.processing">詳細を隠す</span>
              </button>
            </div>
            <button @click="compareAllHashes()" :disabled="!hashState.inputText">
              全アルゴリズムで計算
            </button>

            <!-- Comparison Results Table -->
            <div x-show="Object.keys(hashState.comparisonResults).length > 0" class="output">
              <strong>性能比較結果:</strong>
              <table style="width: 100%; border-collapse: collapse; margin-top: 10px;">
                <thead>
                  <tr style="background-color: #f0f0f0;">
                    <th style="padding: 8px; border: 1px solid #ddd; text-align: left; color: #333; font-weight: bold;">
                      アルゴリズム</th>
                    <th
                      style="padding: 8px; border: 1px solid #ddd; text-align: right; color: #333; font-weight: bold;">
                      処理時間 (ms)</th>
                    <th
                      style="padding: 8px; border: 1px solid #ddd; text-align: right; color: #333; font-weight: bold;">
                      出力サイズ (bit)</th>
                  </tr>
                </thead>
                <tbody>
                  <template x-for="(result, algorithm) in hashState.comparisonResults" :key="algorithm">
                    <tr>
                      <td style="padding: 8px; border: 1px solid #ddd;" x-text="algorithm"></td>
                      <td style="padding: 8px; border: 1px solid #ddd; text-align: right;"
                        x-text="result.time.toFixed(3)"></td>
                      <td style="padding: 8px; border: 1px solid #ddd; text-align: right;"
                        x-text="result.hash.length / 2 * 8"></td>
                    </tr>
                  </template>
                </tbody>
              </table>
            </div>

            <div x-show="hashState.showDetails.processing && Object.keys(hashState.comparisonResults).length > 0"
              class="detail-section">
              <h4>🔍 比較計算の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 入力データ</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    UTF-8エンコードされたバイト配列
                  </div>
                  <div class="param-label">
                    <span x-text="new TextEncoder().encode(hashState.inputText).length"></span> バイト
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. 全アルゴリズムで計算</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    SHA-256, SHA-512, SHA-3-256, BLAKE2b, BLAKE3<br />
                    各アルゴリズムの処理時間を計測
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. 比較結果</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    全アルゴリズムで計算完了
                  </div>
                </div>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. 入力データを全アルゴリズム（SHA-256, SHA-512, SHA-3-256, BLAKE2b, BLAKE3）で計算します。<br />
                2. 各アルゴリズムの処理時間を計測し、性能を比較できます。<br />
                3. 出力サイズも比較できます（SHA-256/SHA-3-256/BLAKE3: 256ビット、SHA-512/BLAKE2b: 512ビット）。
              </div>
            </div>
          </div>

          <!-- Comparison Results -->
          <div x-show="Object.keys(hashState.comparisonResults).length > 0" class="step">
            <div class="step-title">
              <span class="step-number">3</span>
              比較結果
              <button class="detail-toggle" @click="hashState.showDetails.output = !hashState.showDetails.output"
                x-show="Object.keys(hashState.comparisonResults).length > 0">
                <span x-show="!hashState.showDetails.output">詳細を表示</span>
                <span x-show="hashState.showDetails.output">詳細を隠す</span>
              </button>
            </div>

            <!-- Comparison Mode Output -->
            <div class="output">
              <template x-for="(result, algorithm) in hashState.comparisonResults" :key="algorithm">
                <div style="margin-top: 10px; padding: 10px; border: 1px solid #ddd; border-radius: 4px;">
                  <strong x-text="algorithm"></strong><br />
                  ハッシュ値 (16進数): <span style="word-break: break-all; font-family: monospace; font-size: 0.9em;"
                    x-text="result.hash"></span><br />
                  処理時間: <span x-text="result.time.toFixed(3)"></span> ms |
                  出力サイズ: <span x-text="result.hash.length / 2"></span> バイト
                  (<span x-text="result.hash.length / 2 * 8"></span> ビット)
                </div>
              </template>
            </div>

            <div x-show="hashState.showDetails.output && Object.keys(hashState.comparisonResults).length > 0"
              class="detail-section">
              <h4>🔍 比較結果の詳細</h4>
              <template x-for="(result, algorithm) in hashState.comparisonResults" :key="algorithm">
                <div style="margin-top: 15px; padding: 10px; border: 1px solid #ddd; border-radius: 4px;">
                  <h4 x-text="algorithm"></h4>
                  <div class="data-flow">
                    <div class="data-box">
                      <div class="data-box-label">ハッシュ値 (16進数)</div>
                      <div class="data-box-content"
                        style="font-family: monospace; word-break: break-all; font-size: 10px;">
                        <span x-text="result.hash"></span>
                      </div>
                      <div class="param-label">
                        長さ: <span x-text="result.hash.length / 2"></span> バイト
                        (<span x-text="result.hash.length / 2 * 8"></span> ビット)
                      </div>
                    </div>
                  </div>
                  <div style="margin-top: 10px; font-size: 0.9em; color: #666;">
                    処理時間: <span x-text="result.time.toFixed(3)"></span> ms
                  </div>
                </div>
              </template>
            </div>
          </div>

          <div x-show="hashState.error" style="color: #e74c3c; margin-top: 10px;" x-text="hashState.error"></div>
        </div>
      </div>
    </template>

    <!-- Hash Functions - SHA-3-256 -->
    <template x-if="selectedCrypto === 'hash-sha3-256'">
      <div>
        <div class="section">
          <h2>SHA-3-256 の動作</h2>
          <div class="info">
            <strong>概要:</strong><br />
            SHA-3-256は、任意の長さのデータから256ビット（32バイト）のハッシュ値を生成する一方向関数です。<br />
            主な用途: データの整合性検証、パスワード保存、デジタル署名、メッセージ認証など<br />
            <br />
            <strong>特徴:</strong><br />
            • NIST標準の暗号学的ハッシュ関数（SHA-2の代替）<br />
            • Sponge構造（Keccak）<br />
            • 256ビット（32バイト）の固定長出力<br />
            • SHA-2とは異なる構造で、将来の安全性を考慮
          </div>

          <!-- Input Section -->
          <div class="step">
            <div class="step-title">
              <span class="step-number">1</span>
              入力データ
              <button class="detail-toggle" @click="hashState.showDetails.input = !hashState.showDetails.input"
                x-show="hashState.inputText">
                <span x-show="!hashState.showDetails.input">詳細を表示</span>
                <span x-show="hashState.showDetails.input">詳細を隠す</span>
              </button>
            </div>

            <div class="param-group">
              <label for="hash-input-sha3-256">入力テキスト:</label>
              <textarea id="hash-input-sha3-256" x-model="hashState.inputText" rows="4"
                placeholder="ハッシュ値を計算したいテキストを入力してください"
                @input="hashState.error = ''; hashState.hash = null; hashState.comparisonResults = {};"></textarea>
            </div>

            <div x-show="hashState.inputText" class="output">
              <strong>入力サイズ:</strong>
              <span x-text="new TextEncoder().encode(hashState.inputText).length"></span> バイト
              (<span x-text="hashState.inputText.length"></span> 文字)
            </div>

            <div x-show="hashState.showDetails.input && hashState.inputText" class="detail-section">
              <h4>🔍 入力データの詳細</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. テキスト入力</div>
                  <div class="data-box-content" style="max-height: 100px; overflow: auto;" x-text="hashState.inputText">
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. UTF-8エンコード</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    TextEncoderを使用してバイト配列に変換
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. バイト配列</div>
                  <div class="data-box-content"
                    style="font-family: monospace; word-break: break-all; max-height: 100px; overflow: auto;">
                    <template
                      x-for="(byte, index) in Array.from(new TextEncoder().encode(hashState.inputText)).slice(0, 64)"
                      :key="index">
                      <span x-text="byte.toString(16).padStart(2, '0') + ' '"></span>
                    </template>
                    <span x-show="new TextEncoder().encode(hashState.inputText).length > 64">...</span>
                  </div>
                  <div class="param-label">
                    長さ: <span x-text="new TextEncoder().encode(hashState.inputText).length"></span> バイト
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Hash Computation -->
          <div class="step" x-init="hashState.selectedAlgorithm = 'sha3-256'; hashState.comparisonMode = false;">
            <div class="step-title">
              <span class="step-number">2</span>
              ハッシュ値の計算
              <button class="detail-toggle"
                @click="hashState.showDetails.processing = !hashState.showDetails.processing" x-show="hashState.hash">
                <span x-show="!hashState.showDetails.processing">詳細を表示</span>
                <span x-show="hashState.showDetails.processing">詳細を隠す</span>
              </button>
            </div>
            <button @click="computeHash()" :disabled="!hashState.inputText">
              ハッシュ値を計算
            </button>

            <div x-show="hashState.hash" class="output">
              <strong>計算時間:</strong> <span x-text="hashState.processingTime.toFixed(3)"></span> ミリ秒<br />
              <strong>出力サイズ:</strong> <span x-text="(hashState.hash || []).length"></span> バイト
              (<span x-text="(hashState.hash || []).length * 8"></span> ビット)
            </div>

            <div x-show="hashState.showDetails.processing && hashState.hash" class="detail-section">
              <h4>🔍 ハッシュ計算の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 入力データ</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    UTF-8エンコードされたバイト配列
                  </div>
                  <div class="param-label">
                    <span x-text="new TextEncoder().encode(hashState.inputText).length"></span> バイト
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. SHA-3-256でハッシュ化</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    SHA-3-256 (Sponge構造)<br />
                    一方向関数による変換
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. ハッシュ値</div>
                  <div class="data-box-content" style="font-family: monospace; word-break: break-all; font-size: 10px;">
                    <template x-for="(byte, index) in Array.from(hashState.hash || []).slice(0, 16)" :key="index">
                      <span x-text="byte.toString(16).padStart(2, '0') + ' '"></span>
                    </template>
                    <span x-show="(hashState.hash || []).length > 16">...</span>
                  </div>
                  <div class="param-label">
                    <span x-text="(hashState.hash || []).length"></span> バイト（固定長）
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Output Section -->
          <div x-show="hashState.hash" class="step">
            <div class="step-title">
              <span class="step-number">3</span>
              ハッシュ値 (出力)
              <button class="detail-toggle" @click="hashState.showDetails.output = !hashState.showDetails.output"
                x-show="hashState.hash">
                <span x-show="!hashState.showDetails.output">詳細を表示</span>
                <span x-show="hashState.showDetails.output">詳細を隠す</span>
              </button>
            </div>

            <div x-show="hashState.hash" class="output">
              <strong>ハッシュ値 (16進数):</strong><br />
              <span style="word-break: break-all; font-family: monospace;"
                x-text="Array.from(hashState.hash || []).map(b => b.toString(16).padStart(2, '0')).join('')"></span><br /><br />
              <strong>ハッシュ値 (Base64):</strong><br />
              <span style="word-break: break-all; font-family: monospace;"
                x-text="btoa(String.fromCharCode(...Array.from(hashState.hash || [])))"></span><br /><br />
              <strong>出力サイズ:</strong> <span x-text="(hashState.hash || []).length"></span> バイト
              (<span x-text="(hashState.hash || []).length * 8"></span> ビット)
            </div>

            <div x-show="hashState.showDetails.output && hashState.hash" class="detail-section">
              <h4>🔍 ハッシュ値の詳細</h4>
              <div>
                <div class="data-flow">
                  <div class="data-box">
                    <div class="data-box-label">ハッシュ値 (16進数)</div>
                    <div class="data-box-content"
                      style="font-family: monospace; word-break: break-all; font-size: 10px;">
                      <span
                        x-text="Array.from(hashState.hash || []).map(b => b.toString(16).padStart(2, '0')).join('')"></span>
                    </div>
                    <div class="param-label">
                      長さ: <span x-text="(hashState.hash || []).length"></span> バイト
                      (<span x-text="(hashState.hash || []).length * 8"></span> ビット)
                    </div>
                  </div>
                </div>

                <div style="margin-top: 15px;">
                  <strong>ハッシュ値 (Base64):</strong>
                  <div class="output"
                    style="margin-top: 5px; word-break: break-all; font-family: monospace; font-size: 0.9em;">
                    <span x-text="btoa(String.fromCharCode(...Array.from(hashState.hash || [])))"></span>
                  </div>
                </div>

                <!-- Byte Table Display -->
                <div class="bytes-detail" style="margin-top: 15px;">
                  <h4>ハッシュ値のバイト詳細</h4>
                  <table>
                    <thead>
                      <tr>
                        <th>位置</th>
                        <th>16進数</th>
                        <th>10進数</th>
                        <th>2進数（8ビット）</th>
                      </tr>
                    </thead>
                    <tbody>
                      <template x-for="(byte, index) in Array.from(hashState.hash || [])" :key="index">
                        <tr>
                          <td x-text="index"></td>
                          <td x-text="byte.toString(16).padStart(2, '0').toUpperCase()"></td>
                          <td x-text="byte"></td>
                          <td x-text="byte.toString(2).padStart(8, '0')"></td>
                        </tr>
                      </template>
                    </tbody>
                  </table>
                </div>

                <div style="margin-top: 15px;">
                  <strong>バイト単位表示:</strong>
                  <div class="byte-display" style="margin-top: 5px;">
                    <template x-for="(byte, index) in Array.from(hashState.hash || [])" :key="index">
                      <span class="byte" x-text="byte.toString(16).padStart(2, '0')"
                        :title="'Byte ' + index + ': 0x' + byte.toString(16).padStart(2, '0') + ' (' + byte + ')'"></span>
                    </template>
                  </div>
                </div>
              </div>

              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. ハッシュ関数は、任意の長さの入力データから固定長の出力（ハッシュ値）を生成します。<br />
                2. ハッシュ値は16進数やBase64形式で表示できます。<br />
                3. 同じ入力に対しては、常に同じハッシュ値が生成されます（決定性）。<br />
                4. ハッシュ値から元のデータを復元することは計算量的に困難です（一方向性）。
              </div>
            </div>
          </div>

          <!-- Hash Function Properties -->
          <div class="section">
            <h3>ハッシュ関数の性質</h3>
            <div class="info">
              <strong>構造:</strong><br />
              • <strong>SHA-3-256</strong>: Sponge構造 (Keccak)
            </div>
          </div>

          <div x-show="hashState.error" style="color: #e74c3c; margin-top: 10px;" x-text="hashState.error"></div>
        </div>
      </div>
    </template>

    <!-- Hash Functions - BLAKE2b -->
    <template x-if="selectedCrypto === 'hash-blake2b'">
      <div>
        <div class="section">
          <h2>BLAKE2b の動作</h2>
          <div class="info">
            <strong>概要:</strong><br />
            BLAKE2bは、任意の長さのデータから512ビット（64バイト）のハッシュ値を生成する一方向関数です。<br />
            主な用途: データの整合性検証、パスワード保存、デジタル署名、メッセージ認証など<br />
            <br />
            <strong>特徴:</strong><br />
            • SHA-2より高速で安全性も高い<br />
            • HAIFA構造（ARXベース）<br />
            • 512ビット（64バイト）の固定長出力<br />
            • 暗号通貨などで広く採用
          </div>

          <!-- Input Section -->
          <div class="step">
            <div class="step-title">
              <span class="step-number">1</span>
              入力データ
              <button class="detail-toggle" @click="hashState.showDetails.input = !hashState.showDetails.input"
                x-show="hashState.inputText">
                <span x-show="!hashState.showDetails.input">詳細を表示</span>
                <span x-show="hashState.showDetails.input">詳細を隠す</span>
              </button>
            </div>

            <div class="param-group">
              <label for="hash-input-blake2b">入力テキスト:</label>
              <textarea id="hash-input-blake2b" x-model="hashState.inputText" rows="4"
                placeholder="ハッシュ値を計算したいテキストを入力してください"
                @input="hashState.error = ''; hashState.hash = null; hashState.comparisonResults = {};"></textarea>
            </div>

            <div x-show="hashState.inputText" class="output">
              <strong>入力サイズ:</strong>
              <span x-text="new TextEncoder().encode(hashState.inputText).length"></span> バイト
              (<span x-text="hashState.inputText.length"></span> 文字)
            </div>
          </div>

          <!-- Hash Computation -->
          <div class="step" x-init="hashState.selectedAlgorithm = 'blake2b'; hashState.comparisonMode = false;">
            <div class="step-title">
              <span class="step-number">2</span>
              ハッシュ値の計算
              <button class="detail-toggle"
                @click="hashState.showDetails.processing = !hashState.showDetails.processing" x-show="hashState.hash">
                <span x-show="!hashState.showDetails.processing">詳細を表示</span>
                <span x-show="hashState.showDetails.processing">詳細を隠す</span>
              </button>
            </div>
            <button @click="computeHash()" :disabled="!hashState.inputText">
              ハッシュ値を計算
            </button>

            <div x-show="hashState.hash" class="output">
              <strong>計算時間:</strong> <span x-text="hashState.processingTime.toFixed(3)"></span> ミリ秒<br />
              <strong>出力サイズ:</strong> <span x-text="(hashState.hash || []).length"></span> バイト
              (<span x-text="(hashState.hash || []).length * 8"></span> ビット)
            </div>

            <div x-show="hashState.showDetails.processing && hashState.hash" class="detail-section">
              <h4>🔍 ハッシュ計算の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 入力データ</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    UTF-8エンコードされたバイト配列
                  </div>
                  <div class="param-label">
                    <span x-text="new TextEncoder().encode(hashState.inputText).length"></span> バイト
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. BLAKE2bでハッシュ化</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    BLAKE2b (HAIFA構造)<br />
                    一方向関数による変換
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. ハッシュ値</div>
                  <div class="data-box-content" style="font-family: monospace; word-break: break-all; font-size: 10px;">
                    <template x-for="(byte, index) in Array.from(hashState.hash || []).slice(0, 16)" :key="index">
                      <span x-text="byte.toString(16).padStart(2, '0') + ' '"></span>
                    </template>
                    <span x-show="(hashState.hash || []).length > 16">...</span>
                  </div>
                  <div class="param-label">
                    <span x-text="(hashState.hash || []).length"></span> バイト（固定長）
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Output Section -->
          <div x-show="hashState.hash" class="step">
            <div class="step-title">
              <span class="step-number">3</span>
              ハッシュ値 (出力)
              <button class="detail-toggle" @click="hashState.showDetails.output = !hashState.showDetails.output"
                x-show="hashState.hash">
                <span x-show="!hashState.showDetails.output">詳細を表示</span>
                <span x-show="hashState.showDetails.output">詳細を隠す</span>
              </button>
            </div>

            <div x-show="hashState.hash" class="output">
              <strong>ハッシュ値 (16進数):</strong><br />
              <span style="word-break: break-all; font-family: monospace;"
                x-text="Array.from(hashState.hash || []).map(b => b.toString(16).padStart(2, '0')).join('')"></span><br /><br />
              <strong>ハッシュ値 (Base64):</strong><br />
              <span style="word-break: break-all; font-family: monospace;"
                x-text="btoa(String.fromCharCode(...Array.from(hashState.hash || [])))"></span><br /><br />
              <strong>出力サイズ:</strong> <span x-text="(hashState.hash || []).length"></span> バイト
              (<span x-text="(hashState.hash || []).length * 8"></span> ビット)
            </div>

            <div x-show="hashState.showDetails.output && hashState.hash" class="detail-section">
              <h4>🔍 ハッシュ値の詳細</h4>
              <div>
                <div class="data-flow">
                  <div class="data-box">
                    <div class="data-box-label">ハッシュ値 (16進数)</div>
                    <div class="data-box-content"
                      style="font-family: monospace; word-break: break-all; font-size: 10px;">
                      <span
                        x-text="Array.from(hashState.hash || []).map(b => b.toString(16).padStart(2, '0')).join('')"></span>
                    </div>
                    <div class="param-label">
                      長さ: <span x-text="(hashState.hash || []).length"></span> バイト
                      (<span x-text="(hashState.hash || []).length * 8"></span> ビット)
                    </div>
                  </div>
                </div>

                <div style="margin-top: 15px;">
                  <strong>ハッシュ値 (Base64):</strong>
                  <div class="output"
                    style="margin-top: 5px; word-break: break-all; font-family: monospace; font-size: 0.9em;">
                    <span x-text="btoa(String.fromCharCode(...Array.from(hashState.hash || [])))"></span>
                  </div>
                </div>

                <!-- Byte Table Display -->
                <div class="bytes-detail" style="margin-top: 15px;">
                  <h4>ハッシュ値のバイト詳細</h4>
                  <table>
                    <thead>
                      <tr>
                        <th>位置</th>
                        <th>16進数</th>
                        <th>10進数</th>
                        <th>2進数（8ビット）</th>
                      </tr>
                    </thead>
                    <tbody>
                      <template x-for="(byte, index) in Array.from(hashState.hash || [])" :key="index">
                        <tr>
                          <td x-text="index"></td>
                          <td x-text="byte.toString(16).padStart(2, '0').toUpperCase()"></td>
                          <td x-text="byte"></td>
                          <td x-text="byte.toString(2).padStart(8, '0')"></td>
                        </tr>
                      </template>
                    </tbody>
                  </table>
                </div>

                <div style="margin-top: 15px;">
                  <strong>バイト単位表示:</strong>
                  <div class="byte-display" style="margin-top: 5px;">
                    <template x-for="(byte, index) in Array.from(hashState.hash || [])" :key="index">
                      <span class="byte" x-text="byte.toString(16).padStart(2, '0')"
                        :title="'Byte ' + index + ': 0x' + byte.toString(16).padStart(2, '0') + ' (' + byte + ')'"></span>
                    </template>
                  </div>
                </div>
              </div>

              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. ハッシュ関数は、任意の長さの入力データから固定長（512ビット/64バイト）の出力（ハッシュ値）を生成します。<br />
                2. ハッシュ値は16進数やBase64形式で表示できます。<br />
                3. 同じ入力に対しては、常に同じハッシュ値が生成されます（決定性）。<br />
                4. ハッシュ値から元のデータを復元することは計算量的に困難です（一方向性）。
              </div>
            </div>
          </div>

          <!-- Hash Function Properties -->
          <div class="section">
            <h3>ハッシュ関数の性質</h3>
            <div class="info">
              <strong>暗号学的ハッシュ関数の要件:</strong><br />
              1. <strong>一方向性</strong>: ハッシュ値から元のデータを復元することが計算量的に困難<br />
              2. <strong>決定性</strong>: 同じ入力に対しては常に同じハッシュ値を生成<br />
              3. <strong>固定長出力</strong>: 入力の長さに関わらず、常に固定長（512ビット/64バイト）の出力を生成<br />
              4. <strong>衝突困難性</strong>: 異なる入力から同じハッシュ値を生成することが困難<br />
              5. <strong>雪崩効果</strong>: 入力の1ビットの変化が出力の約半分のビットを変化させる<br />
              <br />
              <strong>構造:</strong><br />
              • <strong>BLAKE2b</strong>: HAIFA構造 (ARXベース)
            </div>
          </div>

          <div x-show="hashState.error" style="color: #e74c3c; margin-top: 10px;" x-text="hashState.error"></div>
        </div>
      </div>
    </template>

    <!-- Hash Functions - BLAKE3 -->
    <template x-if="selectedCrypto === 'hash-blake3'">
      <div>
        <div class="section">
          <h2>BLAKE3 の動作</h2>
          <div class="info">
            <strong>概要:</strong><br />
            BLAKE3は、任意の長さのデータから256ビット（32バイト）のハッシュ値を生成する一方向関数です。<br />
            主な用途: データの整合性検証、パスワード保存、デジタル署名、メッセージ認証など<br />
            <br />
            <strong>特徴:</strong><br />
            • BLAKE2の後継、並列処理可能で非常に高速<br />
            • Merkle tree構造<br />
            • 256ビット（32バイト）の固定長出力<br />
            • 非常に高速な実装
          </div>

          <!-- Input Section -->
          <div class="step">
            <div class="step-title">
              <span class="step-number">1</span>
              入力データ
              <button class="detail-toggle" @click="hashState.showDetails.input = !hashState.showDetails.input"
                x-show="hashState.inputText">
                <span x-show="!hashState.showDetails.input">詳細を表示</span>
                <span x-show="hashState.showDetails.input">詳細を隠す</span>
              </button>
            </div>

            <div class="param-group">
              <label for="hash-input-blake3">入力テキスト:</label>
              <textarea id="hash-input-blake3" x-model="hashState.inputText" rows="4"
                placeholder="ハッシュ値を計算したいテキストを入力してください"
                @input="hashState.error = ''; hashState.hash = null; hashState.comparisonResults = {};"></textarea>
            </div>

            <div x-show="hashState.inputText" class="output">
              <strong>入力サイズ:</strong>
              <span x-text="new TextEncoder().encode(hashState.inputText).length"></span> バイト
              (<span x-text="hashState.inputText.length"></span> 文字)
            </div>
          </div>

          <!-- Hash Computation -->
          <div class="step" x-init="hashState.selectedAlgorithm = 'blake3'; hashState.comparisonMode = false;">
            <div class="step-title">
              <span class="step-number">2</span>
              ハッシュ値の計算
              <button class="detail-toggle"
                @click="hashState.showDetails.processing = !hashState.showDetails.processing" x-show="hashState.hash">
                <span x-show="!hashState.showDetails.processing">詳細を表示</span>
                <span x-show="hashState.showDetails.processing">詳細を隠す</span>
              </button>
            </div>
            <button @click="computeHash()" :disabled="!hashState.inputText">
              ハッシュ値を計算
            </button>

            <div x-show="hashState.hash" class="output">
              <strong>計算時間:</strong> <span x-text="hashState.processingTime.toFixed(3)"></span> ミリ秒<br />
              <strong>出力サイズ:</strong> <span x-text="(hashState.hash || []).length"></span> バイト
              (<span x-text="(hashState.hash || []).length * 8"></span> ビット)
            </div>

            <div x-show="hashState.showDetails.processing && hashState.hash" class="detail-section">
              <h4>🔍 ハッシュ計算の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 入力データ</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    UTF-8エンコードされたバイト配列
                  </div>
                  <div class="param-label">
                    <span x-text="new TextEncoder().encode(hashState.inputText).length"></span> バイト
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. BLAKE3でハッシュ化</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    BLAKE3 (Merkle tree構造)<br />
                    一方向関数による変換
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. ハッシュ値</div>
                  <div class="data-box-content" style="font-family: monospace; word-break: break-all; font-size: 10px;">
                    <template x-for="(byte, index) in Array.from(hashState.hash || []).slice(0, 16)" :key="index">
                      <span x-text="byte.toString(16).padStart(2, '0') + ' '"></span>
                    </template>
                    <span x-show="(hashState.hash || []).length > 16">...</span>
                  </div>
                  <div class="param-label">
                    <span x-text="(hashState.hash || []).length"></span> バイト（固定長）
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Output Section -->
          <div x-show="hashState.hash" class="step">
            <div class="step-title">
              <span class="step-number">3</span>
              ハッシュ値 (出力)
              <button class="detail-toggle" @click="hashState.showDetails.output = !hashState.showDetails.output"
                x-show="hashState.hash">
                <span x-show="!hashState.showDetails.output">詳細を表示</span>
                <span x-show="hashState.showDetails.output">詳細を隠す</span>
              </button>
            </div>

            <div x-show="hashState.hash" class="output">
              <strong>ハッシュ値 (16進数):</strong><br />
              <span style="word-break: break-all; font-family: monospace;"
                x-text="Array.from(hashState.hash || []).map(b => b.toString(16).padStart(2, '0')).join('')"></span><br /><br />
              <strong>ハッシュ値 (Base64):</strong><br />
              <span style="word-break: break-all; font-family: monospace;"
                x-text="btoa(String.fromCharCode(...Array.from(hashState.hash || [])))"></span><br /><br />
              <strong>出力サイズ:</strong> <span x-text="(hashState.hash || []).length"></span> バイト
              (<span x-text="(hashState.hash || []).length * 8"></span> ビット)
            </div>

            <div x-show="hashState.showDetails.output && hashState.hash" class="detail-section">
              <h4>🔍 ハッシュ値の詳細</h4>
              <div>
                <div class="data-flow">
                  <div class="data-box">
                    <div class="data-box-label">ハッシュ値 (16進数)</div>
                    <div class="data-box-content"
                      style="font-family: monospace; word-break: break-all; font-size: 10px;">
                      <span
                        x-text="Array.from(hashState.hash || []).map(b => b.toString(16).padStart(2, '0')).join('')"></span>
                    </div>
                    <div class="param-label">
                      長さ: <span x-text="(hashState.hash || []).length"></span> バイト
                      (<span x-text="(hashState.hash || []).length * 8"></span> ビット)
                    </div>
                  </div>
                </div>

                <div style="margin-top: 15px;">
                  <strong>ハッシュ値 (Base64):</strong>
                  <div class="output"
                    style="margin-top: 5px; word-break: break-all; font-family: monospace; font-size: 0.9em;">
                    <span x-text="btoa(String.fromCharCode(...Array.from(hashState.hash || [])))"></span>
                  </div>
                </div>

                <!-- Byte Table Display -->
                <div class="bytes-detail" style="margin-top: 15px;">
                  <h4>ハッシュ値のバイト詳細</h4>
                  <table>
                    <thead>
                      <tr>
                        <th>位置</th>
                        <th>16進数</th>
                        <th>10進数</th>
                        <th>2進数（8ビット）</th>
                      </tr>
                    </thead>
                    <tbody>
                      <template x-for="(byte, index) in Array.from(hashState.hash || [])" :key="index">
                        <tr>
                          <td x-text="index"></td>
                          <td x-text="byte.toString(16).padStart(2, '0').toUpperCase()"></td>
                          <td x-text="byte"></td>
                          <td x-text="byte.toString(2).padStart(8, '0')"></td>
                        </tr>
                      </template>
                    </tbody>
                  </table>
                </div>

                <div style="margin-top: 15px;">
                  <strong>バイト単位表示:</strong>
                  <div class="byte-display" style="margin-top: 5px;">
                    <template x-for="(byte, index) in Array.from(hashState.hash || [])" :key="index">
                      <span class="byte" x-text="byte.toString(16).padStart(2, '0')"
                        :title="'Byte ' + index + ': 0x' + byte.toString(16).padStart(2, '0') + ' (' + byte + ')'"></span>
                    </template>
                  </div>
                </div>
              </div>

              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. ハッシュ関数は、任意の長さの入力データから固定長の出力（ハッシュ値）を生成します。<br />
                2. ハッシュ値は16進数やBase64形式で表示できます。<br />
                3. 同じ入力に対しては、常に同じハッシュ値が生成されます（決定性）。<br />
                4. ハッシュ値から元のデータを復元することは計算量的に困難です（一方向性）。
              </div>
            </div>
          </div>

          <!-- Hash Function Properties -->
          <div class="section">
            <h3>ハッシュ関数の性質</h3>
            <div class="info">
              <strong>構造:</strong><br />
              • <strong>BLAKE3</strong>: Merkle tree構造
            </div>
          </div>

          <div x-show="hashState.error" style="color: #e74c3c; margin-top: 10px;" x-text="hashState.error"></div>
        </div>
      </div>
    </template>

    <!-- Post-Quantum Cryptography - Kyber -->
    <template x-if="selectedCrypto === 'kyber'">
      <div>
        <div class="section">
          <h2>CRYSTALS-Kyber (ML-KEM) の動作</h2>
          <div class="info">
            <strong>ML-KEM (Module-Lattice Key Encapsulation Mechanism)</strong><br />
            CRYSTALS-Kyberは、NIST標準化された耐量子暗号アルゴリズムです。<br />
            鍵カプセル化メカニズム（KEM）を使用して、安全な鍵交換を実現します。<br />
            <span style="font-size: 0.9em; color: #e8f4f8; font-style: italic;">
              ※ この実装はWebAssemblyでコンパイルされたRust実装を使用しています。
            </span>
          </div>

          <!-- 初期化 -->
          <div class="subsection">
            <h3>1. 初期化</h3>
            <button @click="initKyber()" :disabled="kyberState.initialized">WebAssemblyモジュールを初期化</button>
            <div x-show="kyberState.initialized" class="output">✅ 初期化完了</div>
            <div x-show="kyberState.showDetails.initialization && kyberState.initialized" class="detail-section">
              <div class="data-box">
                <div class="data-box-header">初期化完了</div>
                <div class="data-box-content">
                  ML-KEMが使用可能になりました。鍵ペア生成、カプセル化、デカプセル化の各操作を実行できます。
                </div>
              </div>
            </div>
          </div>

          <!-- 鍵ペア生成 -->
          <div class="subsection">
            <h3>
              <button class="detail-toggle"
                @click="kyberState.showDetails.keyGeneration = !kyberState.showDetails.keyGeneration"
                x-show="kyberState.publicKey">
                <span x-show="!kyberState.showDetails.keyGeneration">詳細を表示</span>
                <span x-show="kyberState.showDetails.keyGeneration">詳細を隠す</span>
              </button>
              2. 鍵ペアの生成
            </h3>
            <button @click="generateKyberKeyPair()" :disabled="!kyberState.initialized">鍵ペアを生成</button>
            <div x-show="kyberState.publicKey" class="output">
              <div><strong>公開鍵:</strong> <span x-text="formatBytes(kyberState.publicKey)"></span></div>
              <div><strong>公開鍵サイズ:</strong> <span x-text="kyberState.publicKey?.length"></span> バイト</div>
              <div style="margin-top: 10px;"><strong>秘密鍵:</strong> <span
                  x-text="formatBytes(kyberState.privateKey)"></span></div>
              <div><strong>秘密鍵サイズ:</strong> <span x-text="kyberState.privateKey?.length"></span> バイト</div>
            </div>
            <div x-show="kyberState.showDetails.keyGeneration && kyberState.publicKey" class="detail-section">
              <h4>🔍 鍵ペア生成の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 暗号学的に安全な乱数生成器を初期化</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    OsRng（オペレーティングシステムの乱数生成器）を使用<br />
                    CSPRNG（暗号学的擬似乱数生成器）として機能
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. ML-KEMのkeygenアルゴリズムを実行</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    ML-KEM.KeyGen()を実行<br />
                    格子ベースの鍵生成（Module-LWE問題に基づく）
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. 公開鍵（EncapsKey）を生成</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    格子の公開パラメータAとベクトルtを生成<br />
                    サイズ: <span x-text="kyberState.publicKey?.length || 0"></span> バイト（1184バイト）
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">4. 秘密鍵（DecapsKey）を生成</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    秘密ベクトルsと公開鍵のハッシュhを保存<br />
                    サイズ: <span x-text="kyberState.privateKey?.length || 0"></span> バイト（2400バイト）
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">5. 鍵をバイト配列にシリアライズ</div>
                  <div class="data-box-content" x-text="formatBytesReadable(kyberState.publicKey)"></div>
                  <div class="param-label">
                    公開鍵: <span x-text="kyberState.publicKey?.length || 0"></span> バイト<br />
                    秘密鍵: <span x-text="kyberState.privateKey?.length || 0"></span> バイト
                  </div>
                </div>
              </div>
              <div class="bytes-detail" x-show="kyberState.publicKey" style="margin-top: 15px;">
                <h4>公開鍵のバイト詳細（最初の32バイト）</h4>
                <table>
                  <thead>
                    <tr>
                      <th>位置</th>
                      <th>16進数</th>
                      <th>10進数</th>
                      <th>2進数（8ビット）</th>
                    </tr>
                  </thead>
                  <tbody>
                    <template x-for="(byte, index) in Array.from((kyberState.publicKey || []).slice(0, 32))"
                      :key="index">
                      <tr>
                        <td x-text="index"></td>
                        <td x-text="byte.toString(16).padStart(2, '0').toUpperCase()"></td>
                        <td x-text="byte"></td>
                        <td x-text="byte.toString(2).padStart(8, '0')"></td>
                      </tr>
                    </template>
                  </tbody>
                </table>
                <div style="margin-top: 10px; font-size: 11px; color: #7f8c8d;">
                  全 <span x-text="kyberState.publicKey?.length || 0"></span> バイト中、最初の32バイトを表示
                </div>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. ML-KEM（Module-Lattice Key Encapsulation Mechanism）は、格子ベースの暗号化方式です。Module-LWE（Learning With
                Errors）問題の困難性に基づいています。<br />
                2. 鍵生成では、乱数生成器を使用して格子の公開パラメータAと秘密ベクトルsを生成します。<br />
                3. 公開鍵（EncapsKey）は、格子の公開パラメータとベクトルt = As + e（eは誤差ベクトル）から構成されます。<br />
                4. 秘密鍵（DecapsKey）は、秘密ベクトルsと公開鍵のハッシュhを保存します。これにより、デカプセル化時に正しい共有秘密を復元できます。<br />
                5. ML-KEM-768（推奨レベル）では、公開鍵は1184バイト、秘密鍵は2400バイトです。
              </div>
            </div>
          </div>

          <!-- カプセル化 -->
          <div class="subsection">
            <h3>
              <button class="detail-toggle"
                @click="kyberState.showDetails.encapsulation = !kyberState.showDetails.encapsulation"
                x-show="kyberState.ciphertext">
                <span x-show="!kyberState.showDetails.encapsulation">詳細を表示</span>
                <span x-show="kyberState.showDetails.encapsulation">詳細を隠す</span>
              </button>
              3. 鍵カプセル化（Encapsulation）
            </h3>
            <button @click="encapsulateKyber()" :disabled="!kyberState.publicKey">カプセル化を実行</button>
            <div x-show="kyberState.ciphertext" class="output">
              <div><strong>暗号文:</strong> <span x-text="formatBytes(kyberState.ciphertext)"></span></div>
              <div><strong>暗号文サイズ:</strong> <span x-text="kyberState.ciphertext?.length"></span> バイト</div>
              <div style="margin-top: 10px;"><strong>共有秘密:</strong> <span
                  x-text="formatBytes(kyberState.sharedSecret)"></span></div>
              <div><strong>共有秘密サイズ:</strong> <span x-text="kyberState.sharedSecret?.length"></span> バイト (32バイト)</div>
            </div>
            <div x-show="kyberState.showDetails.encapsulation && kyberState.ciphertext" class="detail-section">
              <h4>🔍 カプセル化の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. ランダムメッセージmを生成</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    32バイトのランダムメッセージmを生成<br />
                    CSPRNGを使用して暗号学的に安全な乱数を生成
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. 公開鍵でメッセージを暗号化</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    ML-KEM.Encaps(ek, m)を実行<br />
                    格子ベースの暗号化で暗号文cを生成
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. 共有秘密kを生成</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    SHA-3-512を使用してk = H(m, h)を計算<br />
                    hは公開鍵のハッシュ値<br />
                    出力: 32バイトの共有秘密
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">4. 暗号文cを生成</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    暗号化されたメッセージとエラー情報を含む<br />
                    サイズ: <span x-text="kyberState.ciphertext?.length || 0"></span> バイト（1088バイト）
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">5. 出力（暗号文と共有秘密）</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    暗号文: <span x-text="formatBytesReadable(kyberState.ciphertext?.slice(0, 16) || [])"></span>...<br />
                    共有秘密: <span x-text="formatBytesReadable(kyberState.sharedSecret || [])"></span>
                  </div>
                </div>
              </div>
              <div class="bytes-detail" x-show="kyberState.sharedSecret" style="margin-top: 15px;">
                <h4>共有秘密のバイト詳細</h4>
                <table>
                  <thead>
                    <tr>
                      <th>位置</th>
                      <th>16進数</th>
                      <th>10進数</th>
                      <th>2進数（8ビット）</th>
                    </tr>
                  </thead>
                  <tbody>
                    <template x-for="(byte, index) in Array.from(kyberState.sharedSecret || [])" :key="index">
                      <tr>
                        <td x-text="index"></td>
                        <td x-text="byte.toString(16).padStart(2, '0').toUpperCase()"></td>
                        <td x-text="byte"></td>
                        <td x-text="byte.toString(2).padStart(8, '0')"></td>
                      </tr>
                    </template>
                  </tbody>
                </table>
              </div>
              <div class="bytes-detail" x-show="kyberState.ciphertext" style="margin-top: 15px;">
                <h4>暗号文のバイト詳細（最初の32バイト）</h4>
                <table>
                  <thead>
                    <tr>
                      <th>位置</th>
                      <th>16進数</th>
                      <th>10進数</th>
                      <th>2進数（8ビット）</th>
                    </tr>
                  </thead>
                  <tbody>
                    <template x-for="(byte, index) in Array.from((kyberState.ciphertext || []).slice(0, 32))"
                      :key="index">
                      <tr>
                        <td x-text="index"></td>
                        <td x-text="byte.toString(16).padStart(2, '0').toUpperCase()"></td>
                        <td x-text="byte"></td>
                        <td x-text="byte.toString(2).padStart(8, '0')"></td>
                      </tr>
                    </template>
                  </tbody>
                </table>
                <div style="margin-top: 10px; font-size: 11px; color: #7f8c8d;">
                  全 <span x-text="kyberState.ciphertext?.length || 0"></span> バイト中、最初の32バイトを表示
                </div>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. カプセル化（Encapsulation）は、公開鍵を使用して共有秘密を安全に生成し、暗号化するプロセスです。<br />
                2. まず、32バイトのランダムメッセージmを生成します。このメッセージは、共有秘密の生成に使用されます。<br />
                3. 公開鍵（EncapsKey）を使用して、メッセージmを格子ベースの暗号化で暗号化し、暗号文cを生成します。<br />
                4. 共有秘密kは、SHA-3-512ハッシュ関数を使用してk = H(m, h)として計算されます。ここで、hは公開鍵のハッシュ値です。<br />
                5. 暗号文cと共有秘密kのペアが出力されます。暗号文は1088バイト、共有秘密は32バイトです。<br />
                6. 同じ公開鍵で複数回カプセル化を実行すると、異なる暗号文が生成されますが、デカプセル化で正しい共有秘密が復元されます。
              </div>
            </div>
          </div>

          <!-- デカプセル化 -->
          <div class="subsection">
            <h3>
              <button class="detail-toggle"
                @click="kyberState.showDetails.decapsulation = !kyberState.showDetails.decapsulation"
                x-show="kyberState.decapsulatedSecret">
                <span x-show="!kyberState.showDetails.decapsulation">詳細を表示</span>
                <span x-show="kyberState.showDetails.decapsulation">詳細を隠す</span>
              </button>
              4. 鍵デカプセル化（Decapsulation）
            </h3>
            <button @click="decapsulateKyber()"
              :disabled="!kyberState.ciphertext || !kyberState.privateKey">デカプセル化を実行</button>
            <div x-show="kyberState.decapsulatedSecret" class="output">
              <div><strong>復元された共有秘密:</strong> <span x-text="formatBytes(kyberState.decapsulatedSecret)"></span></div>
              <div><strong>共有秘密サイズ:</strong> <span x-text="kyberState.decapsulatedSecret?.length"></span> バイト</div>
              <div x-show="kyberState.sharedSecret && kyberState.decapsulatedSecret"
                style="margin-top: 10px; padding: 10px; background: #d5e8f3; border-radius: 4px;">
                <strong style="color: #2c3e50;">検証結果:</strong>
                <span
                  x-show="Array.from(kyberState.sharedSecret || []).every((b, i) => b === kyberState.decapsulatedSecret?.[i])"
                  style="color: #27ae60;">
                  ✅ 共有秘密が一致しました
                </span>
                <span
                  x-show="!Array.from(kyberState.sharedSecret || []).every((b, i) => b === kyberState.decapsulatedSecret?.[i])"
                  style="color: #e74c3c;">
                  ❌ 共有秘密が一致しませんでした
                </span>
              </div>
            </div>
            <div x-show="kyberState.showDetails.decapsulation && kyberState.decapsulatedSecret" class="detail-section">
              <h4>🔍 デカプセル化の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 暗号文cと秘密鍵dkを入力</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    暗号文: <span x-text="kyberState.ciphertext?.length || 0"></span> バイト<br />
                    秘密鍵: <span x-text="kyberState.privateKey?.length || 0"></span> バイト<br />
                    公開鍵: <span x-text="kyberState.publicKey?.length || 0"></span> バイト（検証用）
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. ML-KEM.Decapsを実行</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    ML-KEM.Decaps(dk, ek, c)を実行<br />
                    秘密鍵dkと公開鍵ekを使用して暗号文cを復号化
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. メッセージm'を復号化</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    格子ベースの復号化でメッセージm'を取得<br />
                    秘密ベクトルsを使用して暗号文からメッセージを復元
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">4. 共有秘密k'を再計算</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    k' = H(m', h)を計算<br />
                    SHA-3-512を使用して共有秘密を再生成<br />
                    hは公開鍵のハッシュ値（秘密鍵に保存）
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">5. 出力（共有秘密k'）</div>
                  <div class="data-box-content" x-text="formatBytesReadable(kyberState.decapsulatedSecret || [])"></div>
                  <div class="param-label">
                    サイズ: <span x-text="kyberState.decapsulatedSecret?.length || 0"></span> バイト（32バイト）
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">6. 検証結果</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    <span
                      x-show="Array.from(kyberState.sharedSecret || []).every((b, i) => b === kyberState.decapsulatedSecret?.[i])"
                      style="color: #27ae60; font-weight: bold;">
                      ✓ k = k'（共有秘密が一致）
                    </span>
                    <span
                      x-show="!Array.from(kyberState.sharedSecret || []).every((b, i) => b === kyberState.decapsulatedSecret?.[i])"
                      style="color: #e74c3c; font-weight: bold;">
                      ✗ k ≠ k'（共有秘密が不一致）
                    </span>
                  </div>
                </div>
              </div>
              <div class="bytes-detail" x-show="kyberState.decapsulatedSecret" style="margin-top: 15px;">
                <h4>復元された共有秘密のバイト詳細</h4>
                <table>
                  <thead>
                    <tr>
                      <th>位置</th>
                      <th>16進数</th>
                      <th>10進数</th>
                      <th>2進数（8ビット）</th>
                    </tr>
                  </thead>
                  <tbody>
                    <template x-for="(byte, index) in Array.from(kyberState.decapsulatedSecret || [])" :key="index">
                      <tr>
                        <td x-text="index"></td>
                        <td x-text="byte.toString(16).padStart(2, '0').toUpperCase()"></td>
                        <td x-text="byte"></td>
                        <td x-text="byte.toString(2).padStart(8, '0')"></td>
                      </tr>
                    </template>
                  </tbody>
                </table>
              </div>
              <div x-show="kyberState.sharedSecret && kyberState.decapsulatedSecret" class="bytes-detail"
                style="margin-top: 15px;">
                <h4>共有秘密の比較</h4>
                <table>
                  <thead>
                    <tr>
                      <th>位置</th>
                      <th>カプセル化時の値</th>
                      <th>デカプセル化時の値</th>
                      <th>一致</th>
                    </tr>
                  </thead>
                  <tbody>
                    <template x-for="(byte, index) in Array.from(kyberState.sharedSecret || [])" :key="index">
                      <tr>
                        <td x-text="index"></td>
                        <td x-text="byte.toString(16).padStart(2, '0').toUpperCase()"></td>
                        <td
                          x-text="(kyberState.decapsulatedSecret?.[index] || 0).toString(16).padStart(2, '0').toUpperCase()">
                        </td>
                        <td>
                          <span x-show="byte === kyberState.decapsulatedSecret?.[index]"
                            style="color: #27ae60;">✓</span>
                          <span x-show="byte !== kyberState.decapsulatedSecret?.[index]"
                            style="color: #e74c3c;">✗</span>
                        </td>
                      </tr>
                    </template>
                  </tbody>
                </table>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. デカプセル化（Decapsulation）は、秘密鍵と暗号文を使用して共有秘密を復元するプロセスです。<br />
                2. 秘密鍵（DecapsKey）には、秘密ベクトルsと公開鍵のハッシュ値hが保存されています。<br />
                3. 暗号文cを秘密ベクトルsを使用して復号化し、元のメッセージm'を取得します。<br />
                4. 共有秘密k'は、カプセル化時と同様にk' = H(m', h)として計算されます。ここで、hは秘密鍵に保存された公開鍵のハッシュ値です。<br />
                5. 正しい秘密鍵でデカプセル化を実行すると、m' = mとなり、k' = kとなります。つまり、カプセル化時に生成された共有秘密と一致します。<br />
                6. この共有秘密kは、その後の対称鍵暗号化（AESなど）の鍵として使用できます。ML-KEMは鍵交換プロトコルとして機能し、安全な鍵配送を実現します。
              </div>
            </div>
          </div>

          <div x-show="kyberState.error" style="color: #e74c3c; margin-top: 10px;" x-text="kyberState.error"></div>
        </div>
      </div>
    </template>

    <!-- Post-Quantum Cryptography - Dilithium -->
    <template x-if="selectedCrypto === 'dilithium'">
      <div>
        <div class="section">
          <h2>CRYSTALS-Dilithium (ML-DSA) の動作</h2>
          <div class="info">
            <strong>ML-DSA (Module-Lattice Digital Signature Algorithm)</strong><br />
            CRYSTALS-Dilithiumは、NIST標準化された耐量子暗号アルゴリズムです。<br />
            デジタル署名アルゴリズムとして、安全な署名生成と検証を実現します。<br />
            <span style="font-size: 0.9em; color: #e8f4f8; font-style: italic;">
              ※ この実装はWebAssemblyでコンパイルされたRust実装を使用しています。ML-DSA-65（推奨レベル）を実装しています。
            </span>
          </div>

          <!-- 初期化 -->
          <div class="subsection">
            <h3>1. 初期化</h3>
            <button @click="initDilithium()" :disabled="dilithiumState.initialized">WebAssemblyモジュールを初期化</button>
            <div x-show="dilithiumState.initialized" class="output">✅ 初期化完了</div>
            <div x-show="dilithiumState.showDetails.initialization && dilithiumState.initialized"
              class="detail-section">
              <div class="data-box">
                <div class="data-box-header">初期化完了</div>
                <div class="data-box-content">
                  ML-DSAが使用可能になりました。鍵ペア生成、署名、検証の各操作を実行できます。
                </div>
              </div>
            </div>
          </div>

          <!-- 鍵ペア生成 -->
          <div class="subsection">
            <h3>
              <button class="detail-toggle"
                @click="dilithiumState.showDetails.keyGeneration = !dilithiumState.showDetails.keyGeneration"
                x-show="dilithiumState.publicKey">
                <span x-show="!dilithiumState.showDetails.keyGeneration">詳細を表示</span>
                <span x-show="dilithiumState.showDetails.keyGeneration">詳細を隠す</span>
              </button>
              2. 鍵ペアの生成
            </h3>
            <button @click="generateDilithiumKeyPair()" :disabled="!dilithiumState.initialized">鍵ペアを生成</button>
            <div x-show="dilithiumState.publicKey" class="output">
              <div><strong>公開鍵:</strong> <span x-text="formatBytes(dilithiumState.publicKey)"></span></div>
              <div><strong>公開鍵サイズ:</strong> <span x-text="dilithiumState.publicKey?.length"></span> バイト</div>
              <div style="margin-top: 10px;"><strong>秘密鍵:</strong> <span
                  x-text="formatBytes(dilithiumState.privateKey)"></span></div>
              <div><strong>秘密鍵サイズ:</strong> <span x-text="dilithiumState.privateKey?.length"></span> バイト</div>
            </div>
            <div x-show="dilithiumState.showDetails.keyGeneration && dilithiumState.publicKey" class="detail-section">
              <h4>🔍 鍵ペア生成の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 暗号学的に安全な乱数生成器を初期化</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    OsRng（オペレーティングシステムの乱数生成器）を使用<br />
                    CSPRNG（暗号学的擬似乱数生成器）として機能
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. ML-DSAのkeygenアルゴリズムを実行</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    ML-DSA.KeyGen()を実行<br />
                    格子ベースの鍵生成（Module-LWE問題に基づく）
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. 公開鍵（VerifyingKey）を生成</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    格子の公開パラメータρと行列A、ベクトルt1を生成<br />
                    サイズ: <span x-text="dilithiumState.publicKey?.length || 0"></span> バイト（1952バイト）
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">4. 秘密鍵（SigningKey）を生成</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    秘密ベクトルs1、s2、t0とハッシュ値tr、kを保存<br />
                    サイズ: <span x-text="dilithiumState.privateKey?.length || 0"></span> バイト（4032バイト）
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">5. 鍵をバイト配列にシリアライズ</div>
                  <div class="data-box-content"
                    x-text="formatBytesReadable(dilithiumState.publicKey?.slice(0, 16) || [])"></div>
                  <div class="param-label">
                    公開鍵: <span x-text="dilithiumState.publicKey?.length || 0"></span> バイト<br />
                    秘密鍵: <span x-text="dilithiumState.privateKey?.length || 0"></span> バイト
                  </div>
                </div>
              </div>
              <div class="bytes-detail" x-show="dilithiumState.publicKey" style="margin-top: 15px;">
                <h4>公開鍵のバイト詳細（最初の32バイト）</h4>
                <table>
                  <thead>
                    <tr>
                      <th>位置</th>
                      <th>16進数</th>
                      <th>10進数</th>
                      <th>2進数（8ビット）</th>
                    </tr>
                  </thead>
                  <tbody>
                    <template x-for="(byte, index) in Array.from((dilithiumState.publicKey || []).slice(0, 32))"
                      :key="index">
                      <tr>
                        <td x-text="index"></td>
                        <td x-text="byte.toString(16).padStart(2, '0').toUpperCase()"></td>
                        <td x-text="byte"></td>
                        <td x-text="byte.toString(2).padStart(8, '0')"></td>
                      </tr>
                    </template>
                  </tbody>
                </table>
                <div style="margin-top: 10px; font-size: 11px; color: #7f8c8d;">
                  全 <span x-text="dilithiumState.publicKey?.length || 0"></span> バイト中、最初の32バイトを表示
                </div>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. ML-DSA（Module-Lattice Digital Signature Algorithm）は、格子ベースのデジタル署名方式です。Module-LWE問題の困難性に基づいています。<br />
                2. 鍵生成では、乱数生成器を使用して格子の公開パラメータρ、行列A、秘密ベクトルs1、s2を生成します。<br />
                3. 公開鍵は、ρ、行列A、ベクトルt1 = As1 + s2から構成されます。ML-DSA-65では、公開鍵は1952バイトです。<br />
                4. 秘密鍵は、秘密ベクトルs1、s2、t0、ハッシュ値tr、kを保存します。これにより、署名生成時に正しい署名を生成できます。ML-DSA-65では、秘密鍵は4032バイトです。<br />
                5. ML-DSA-65は、セキュリティレベル3（192ビット）に対応する推奨レベルのパラメータセットです。
              </div>
            </div>
          </div>

          <!-- 署名 -->
          <div class="subsection">
            <h3>
              <button class="detail-toggle"
                @click="dilithiumState.showDetails.signing = !dilithiumState.showDetails.signing"
                x-show="dilithiumState.signature">
                <span x-show="!dilithiumState.showDetails.signing">詳細を表示</span>
                <span x-show="dilithiumState.showDetails.signing">詳細を隠す</span>
              </button>
              3. デジタル署名
            </h3>
            <label>署名するメッセージ:</label>
            <textarea x-model="dilithiumState.message" placeholder="署名するメッセージを入力"
              @input="dilithiumState.error = ''; dilithiumState.signature = null;"></textarea>
            <button @click="signDilithium()"
              :disabled="!dilithiumState.privateKey || !dilithiumState.message">署名</button>
            <div x-show="dilithiumState.signature" class="output">
              <div><strong>署名:</strong> <span x-text="formatBytes(dilithiumState.signature)"></span></div>
              <div><strong>署名サイズ:</strong> <span x-text="dilithiumState.signature?.length"></span> バイト（3584バイト）</div>
            </div>
            <div x-show="dilithiumState.showDetails.signing && dilithiumState.signature" class="detail-section">
              <h4>🔍 署名の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 入力（文字列）</div>
                  <div class="data-box-content" x-text="dilithiumState.message || '(空)'"></div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. バイト配列に変換</div>
                  <div class="data-box-content" x-text="formatBytesReadable(dilithiumState.messageBytes)"></div>
                  <div class="param-label">長さ: <span x-text="dilithiumState.messageBytes?.length || 0"></span> バイト</div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. メッセージのハッシュ値を計算</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    SHAKE-256を使用してμ = H(tr || m)を計算<br />
                    trは秘密鍵に保存されたハッシュ値
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">4. ランダムマスクyを生成</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    乱数生成器を使用してマスクyを生成<br />
                    yは署名の一意性を保証
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">5. w = Ayを計算</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    公開行列Aとマスクyの積を計算<br />
                    w1とw0に分解
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">6. チャレンジcを生成</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    c = H(μ || w1)を計算<br />
                    cは署名の一部として含まれる
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">7. 応答zを計算</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    z = y + cs1を計算<br />
                    zは署名の一部
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">8. ヒントhを生成</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    w0とcs2からヒントhを生成<br />
                    hは署名の一部として含まれる
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">9. 出力（署名）</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    署名 = (c, z, h)<br />
                    サイズ: <span x-text="dilithiumState.signature?.length || 0"></span> バイト
                  </div>
                </div>
              </div>
              <div class="bytes-detail" x-show="dilithiumState.messageBytes" style="margin-top: 15px;">
                <h4>メッセージのバイト詳細</h4>
                <table>
                  <thead>
                    <tr>
                      <th>位置</th>
                      <th>16進数</th>
                      <th>10進数</th>
                      <th>ASCII</th>
                      <th>文字</th>
                    </tr>
                  </thead>
                  <tbody>
                    <template x-for="(byte, index) in Array.from(dilithiumState.messageBytes || [])" :key="index">
                      <tr>
                        <td x-text="index"></td>
                        <td x-text="byte.toString(16).padStart(2, '0').toUpperCase()"></td>
                        <td x-text="byte"></td>
                        <td x-text="byte >= 32 && byte <= 126 ? String.fromCharCode(byte) : '.'"></td>
                        <td x-text="byte >= 32 && byte <= 126 ? String.fromCharCode(byte) : '(制御文字)'"></td>
                      </tr>
                    </template>
                  </tbody>
                </table>
              </div>
              <div class="bytes-detail" x-show="dilithiumState.signature" style="margin-top: 15px;">
                <h4>署名のバイト詳細（最初の32バイト）</h4>
                <table>
                  <thead>
                    <tr>
                      <th>位置</th>
                      <th>16進数</th>
                      <th>10進数</th>
                      <th>2進数（8ビット）</th>
                    </tr>
                  </thead>
                  <tbody>
                    <template x-for="(byte, index) in Array.from((dilithiumState.signature || []).slice(0, 32))"
                      :key="index">
                      <tr>
                        <td x-text="index"></td>
                        <td x-text="byte.toString(16).padStart(2, '0').toUpperCase()"></td>
                        <td x-text="byte"></td>
                        <td x-text="byte.toString(2).padStart(8, '0')"></td>
                      </tr>
                    </template>
                  </tbody>
                </table>
                <div style="margin-top: 10px; font-size: 11px; color: #7f8c8d;">
                  全 <span x-text="dilithiumState.signature?.length || 0"></span> バイト中、最初の32バイトを表示
                </div>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. メッセージをUTF-8エンコーディングでバイト配列に変換します。<br />
                2. 秘密鍵に保存されたハッシュ値trとメッセージmを連結し、SHAKE-256でハッシュ化してμを計算します。<br />
                3. 乱数生成器を使用してランダムマスクyを生成します。このマスクは署名の一意性を保証します。<br />
                4. 公開行列Aとマスクyの積w = Ayを計算し、w1とw0に分解します。<br />
                5. チャレンジc = H(μ || w1)を計算します。cは署名の一部として含まれます。<br />
                6. 応答z = y + cs1を計算します。zは署名の一部です。<br />
                7. ヒントhを生成します。hはw0とcs2から計算され、署名の一部として含まれます。<br />
                8. 署名は(c, z, h)の形式で出力されます。ML-DSA-65では、署名サイズは3584バイトです。<br />
                9. 同じメッセージでも、ランダムマスクyが異なるため、異なる署名が生成されます。しかし、どちらも有効な署名です。
              </div>
            </div>
            <div x-show="dilithiumState.error" style="color: #e74c3c; margin-top: 10px;" x-text="dilithiumState.error">
            </div>
          </div>

          <!-- 署名検証 -->
          <div class="subsection">
            <h3>
              <button class="detail-toggle"
                @click="dilithiumState.showDetails.verification = !dilithiumState.showDetails.verification"
                x-show="dilithiumState.verified !== null">
                <span x-show="!dilithiumState.showDetails.verification">詳細を表示</span>
                <span x-show="dilithiumState.showDetails.verification">詳細を隠す</span>
              </button>
              4. 署名検証
            </h3>
            <label>検証するメッセージ:</label>
            <textarea x-model="dilithiumState.verificationMessage" placeholder="検証するメッセージを入力"
              @input="dilithiumState.error = ''; dilithiumState.verified = null;"></textarea>
            <button @click="verifyDilithium()"
              :disabled="!dilithiumState.signature || !dilithiumState.publicKey || !dilithiumState.verificationMessage">検証</button>
            <div x-show="dilithiumState.verified !== null" class="output">
              <div x-show="dilithiumState.verified" style="color: #27ae60; font-weight: bold;">
                ✅ 署名は有効です
              </div>
              <div x-show="!dilithiumState.verified" style="color: #e74c3c; font-weight: bold;">
                ❌ 署名は無効です
              </div>
            </div>
            <div x-show="dilithiumState.showDetails.verification && dilithiumState.verified !== null"
              class="detail-section">
              <h4>🔍 署名検証の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 入力データ</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    メッセージ: <span x-text="dilithiumState.verificationMessage || '(空)'"></span><br />
                    署名: <span x-text="dilithiumState.signature?.length || 0"></span> バイト<br />
                    公開鍵: <span x-text="dilithiumState.publicKey?.length || 0"></span> バイト
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. メッセージのハッシュ値を計算</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    SHAKE-256を使用してμ = H(tr || m)を計算<br />
                    trは公開鍵から取得
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. 署名からc、z、hを抽出</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    署名(c, z, h)を解析<br />
                    各コンポーネントを取得
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">4. w1'を再計算</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    w1' = UseHint(h, Az - ct1 * 2^d)を計算<br />
                    ヒントhを使用してw1を復元
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">5. チャレンジc'を再計算</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    c' = H(μ || w1')を計算<br />
                    元のチャレンジcと比較
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">6. 検証結果</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    <span x-show="dilithiumState.verified" style="color: #27ae60; font-weight: bold;">
                      ✓ c = c'（署名は有効）
                    </span>
                    <span x-show="!dilithiumState.verified" style="color: #e74c3c; font-weight: bold;">
                      ✗ c ≠ c'（署名は無効）
                    </span>
                  </div>
                </div>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. 検証するメッセージをUTF-8エンコーディングでバイト配列に変換します。<br />
                2. 公開鍵から取得したtrとメッセージmを連結し、SHAKE-256でハッシュ化してμを計算します。<br />
                3. 署名(c, z, h)から各コンポーネントを抽出します。<br />
                4. ヒントhを使用してw1' = UseHint(h, Az - ct1 * 2^d)を計算します。これにより、署名生成時のw1を復元します。<br />
                5. チャレンジc' = H(μ || w1')を再計算します。<br />
                6. 元のチャレンジcと再計算したc'を比較します。c = c'の場合、署名は有効です。c ≠ c'の場合、署名は無効です。<br />
                7. 正しい公開鍵とメッセージで検証すると、署名は有効になります。異なるメッセージや公開鍵で検証すると、署名は無効になります。
              </div>
            </div>
            <div x-show="dilithiumState.error" style="color: #e74c3c; margin-top: 10px;" x-text="dilithiumState.error">
            </div>
          </div>

          <div x-show="dilithiumState.error" style="color: #e74c3c; margin-top: 10px;" x-text="dilithiumState.error">
          </div>
        </div>
      </div>
    </template>

    <!-- SSE (Searchable Symmetric Encryption) -->
    <template x-if="selectedCrypto === 'sse'">
      <div class="section">
        <h2>検索可能対称暗号 (SSE: Searchable Symmetric Encryption)</h2>
        <div style="margin-bottom: 20px; padding: 15px; background: #e8f4f8; border-radius: 6px; font-size: 14px;">
          <strong>検索可能暗号とは:</strong><br />
          検索可能暗号は、暗号化されたデータに対して直接検索を行うことを可能にする暗号技術です。<br />
          SWP（Song, Wagner, Perrig）スキームを使用して実装されています。<br />
          <strong>特徴:</strong> データはAESで暗号化され、キーワードから生成されたタグを使用して検索が可能です。
        </div>

        <!-- 鍵生成 -->
        <div class="subsection">
          <h3>
            <button class="detail-toggle"
              @click="sseState.showDetails.keyGeneration = !sseState.showDetails.keyGeneration"
              x-show="sseState.masterKey">
              <span x-show="!sseState.showDetails.keyGeneration">詳細を表示</span>
              <span x-show="sseState.showDetails.keyGeneration">詳細を隠す</span>
            </button>
            1. マスター鍵生成
          </h3>
          <button @click="generateSSEKey()">マスター鍵を生成</button>
          <div x-show="sseState.masterKey" class="output">
            <div><strong>マスター鍵:</strong> <span x-text="formatBytes(sseState.masterKey)"></span></div>
            <div><strong>鍵サイズ:</strong> <span x-text="sseState.masterKey?.length"></span> バイト（256ビット）</div>
          </div>
        </div>

        <!-- 暗号化 -->
        <div class="subsection">
          <h3>
            <button class="detail-toggle" @click="sseState.showDetails.encryption = !sseState.showDetails.encryption"
              x-show="sseState.encryptedDocument">
              <span x-show="!sseState.showDetails.encryption">詳細を表示</span>
              <span x-show="sseState.showDetails.encryption">詳細を隠す</span>
            </button>
            2. ドキュメントの暗号化
          </h3>
          <label>平文:</label>
          <textarea x-model="sseState.plaintext" placeholder="暗号化するテキストを入力"
            @input="sseState.error = ''; sseState.encryptedDocument = null;"></textarea>
          <label style="margin-top: 15px;">キーワード（カンマ区切りまたは改行区切り）:</label>
          <div style="display: flex; gap: 10px; margin-bottom: 10px;">
            <input type="text" x-model="sseState.keywordInput" placeholder="キーワードを入力" @keyup.enter="addKeyword()"
              style="flex: 1;">
            <button @click="addKeyword()">追加</button>
          </div>
          <div x-show="sseState.keywords.length > 0" style="margin-bottom: 10px;">
            <div style="display: flex; flex-wrap: wrap; gap: 5px;">
              <template x-for="(keyword, index) in sseState.keywords" :key="index">
                <span
                  style="background: #3498db; color: white; padding: 5px 10px; border-radius: 4px; display: inline-flex; align-items: center; gap: 5px;">
                  <span x-text="keyword"></span>
                  <button @click="removeKeyword(index)"
                    style="background: transparent; border: none; color: white; cursor: pointer; padding: 0; margin-left: 5px;">×</button>
                </span>
              </template>
            </div>
          </div>
          <button @click="encryptSSE()"
            :disabled="!sseState.masterKey || !sseState.plaintext || sseState.keywords.length === 0">暗号化</button>
          <div x-show="sseState.encryptedDocument" class="output" style="margin-top: 10px;">
            <div style="color: #27ae60; font-weight: bold; margin-bottom: 10px;">
              ✅ 暗号化が完了しました。ドキュメントが追加されました。
            </div>
            <div><strong>暗号文:</strong> <span x-text="formatBytes(sseState.encryptedDocument?.ciphertext)"></span></div>
            <div><strong>認証タグ:</strong> <span x-text="formatBytes(sseState.encryptedDocument?.authTag)"></span></div>
            <div><strong>IV:</strong> <span x-text="formatBytes(sseState.encryptedDocument?.iv)"></span></div>
            <div><strong>キーワードタグ数:</strong> <span x-text="sseState.encryptedDocument?.keywordTags?.length || 0"></span>
            </div>
            <div style="margin-top: 10px;">
              <strong>キーワードタグ:</strong>
              <div style="font-size: 12px; margin-top: 5px;">
                <template x-for="(tag, index) in sseState.encryptedDocument?.keywordTags || []" :key="index">
                  <div style="margin-bottom: 5px;">
                    <span x-text="'タグ ' + (index + 1) + ': ' + formatBytes(tag)"></span>
                  </div>
                </template>
              </div>
            </div>
          </div>
        </div>

        <!-- 暗号化済みドキュメント一覧 -->
        <div class="subsection" x-show="sseState.documents.length > 0">
          <h3>暗号化済みドキュメント一覧</h3>
          <div style="margin-bottom: 10px;">
            <strong>ドキュメント数:</strong> <span x-text="sseState.documents.length"></span> 件
          </div>
          <div style="max-height: 300px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; padding: 10px;">
            <template x-for="(item, index) in sseState.documents" :key="index">
              <div
                style="border: 1px solid #ddd; padding: 10px; margin: 5px 0; border-radius: 4px; background: #f9f9f9;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                  <div>
                    <div><strong>ドキュメント #<span x-text="index + 1"></span></strong></div>
                    <div style="font-size: 12px; margin-top: 5px; color: #666;">
                      <div>ID: <span x-text="formatBytes(item.id?.slice(0, 8)) + '...'"></span></div>
                      <div>暗号文サイズ: <span x-text="item.document?.ciphertext?.length || 0"></span> バイト</div>
                      <div>キーワードタグ数: <span x-text="item.document?.keywordTags?.length || 0"></span></div>
                    </div>
                  </div>
                  <div>
                    <button @click="selectDocument(item.id)"
                      style="padding: 5px 10px; font-size: 12px; margin-right: 5px;">
                      選択
                    </button>
                    <button @click="sseState.documents.splice(index, 1); sseState.encryptedDocument = null;"
                      style="padding: 5px 10px; font-size: 12px; background: #e74c3c;">削除</button>
                  </div>
                </div>
                <div
                  x-show="sseState.selectedDocumentId && Array.from(sseState.selectedDocumentId).every((b, i) => b === item.id[i])"
                  style="margin-top: 5px; color: #27ae60; font-size: 12px; font-weight: bold;">
                  ✓ 選択中
                </div>
              </div>
            </template>
          </div>
        </div>

        <!-- 検索 -->
        <div class="subsection">
          <h3>
            <button class="detail-toggle" @click="sseState.showDetails.search = !sseState.showDetails.search"
              x-show="sseState.searchResults.length > 0">
              <span x-show="!sseState.showDetails.search">詳細を表示</span>
              <span x-show="sseState.showDetails.search">詳細を隠す</span>
            </button>
            3. 検索
          </h3>
          <label>検索キーワード:</label>
          <input type="text" x-model="sseState.searchKeyword" placeholder="検索するキーワードを入力"
            @input="sseState.error = ''; sseState.searchResults = [];">
          <button @click="searchSSE()"
            :disabled="!sseState.masterKey || !sseState.searchKeyword || sseState.documents.length === 0">検索</button>
          <div x-show="sseState.searchTag" class="output">
            <div><strong>検索タグ:</strong> <span
                style="word-break: keep-all; white-space: nowrap; overflow-x: auto; display: inline-block;"
                x-text="formatBytes(sseState.searchTag)"></span></div>
            <div><strong>検索結果:</strong> <span x-text="sseState.searchResults.length"></span> 件のドキュメントが見つかりました</div>
            <div x-show="sseState.searchResults.length > 0" style="margin-top: 10px;">
              <template x-for="(item, index) in sseState.searchResults" :key="index">
                <div style="border: 1px solid #ddd; padding: 10px; margin: 5px 0; border-radius: 4px;">
                  <div><strong>ドキュメント #<span x-text="index + 1"></span></strong></div>
                  <div style="font-size: 12px; margin-top: 5px;">
                    <div>暗号文: <span
                        style="word-break: keep-all; white-space: nowrap; overflow-x: auto; display: inline-block;"
                        x-text="formatBytes(item.document?.ciphertext?.slice(0, 32)) + '...'"></span></div>
                    <div>キーワードタグ数: <span x-text="item.document?.keywordTags?.length || 0"></span></div>
                  </div>
                  <!-- 検索結果が複数件の場合のみ選択ボタンを表示 -->
                  <div x-show="sseState.searchResults.length > 1" style="margin-top: 5px;">
                    <button @click="selectDocument(item.id)"
                      style="padding: 5px 10px; font-size: 12px;">このドキュメントを選択</button>
                    <span
                      x-show="sseState.selectedDocumentId && Array.from(sseState.selectedDocumentId).every((b, i) => b === item.id[i])"
                      style="margin-left: 10px; color: #27ae60; font-weight: bold;">✓ 選択中</span>
                  </div>
                  <!-- 検索結果が1件の場合は自動選択されたことを表示 -->
                  <div x-show="sseState.searchResults.length === 1"
                    style="margin-top: 5px; color: #27ae60; font-size: 12px;">
                    ✓ 自動的に選択されました（復号化ボタンで復号化できます）
                  </div>
                </div>
              </template>
            </div>
          </div>
        </div>

        <!-- 復号化 -->
        <div class="subsection">
          <h3>
            <button class="detail-toggle" @click="sseState.showDetails.decryption = !sseState.showDetails.decryption"
              x-show="sseState.decrypted">
              <span x-show="!sseState.showDetails.decryption">詳細を表示</span>
              <span x-show="sseState.showDetails.decryption">詳細を隠す</span>
            </button>
            4. 復号化
          </h3>
          <button @click="decryptSSE()" :disabled="!sseState.masterKey || !sseState.selectedDocumentId">復号化</button>
          <div x-show="sseState.decrypted" class="output">
            <div><strong>復号された平文:</strong></div>
            <div
              style="background: #f0f0f0; color: #333; padding: 10px; border-radius: 4px; margin-top: 5px; white-space: pre-wrap;"
              x-text="sseState.decrypted"></div>
          </div>
        </div>

        <div x-show="sseState.error" style="color: #e74c3c; margin-top: 10px;" x-text="sseState.error">
        </div>
      </div>
    </template>

    <!-- Post-Quantum Cryptography - FALCON -->
    <template x-if="selectedCrypto === 'falcon'">
      <div>
        <div class="section">
          <h2>FALCON (FN-DSA) の動作</h2>
          <div class="info">
            <strong>FN-DSA (Falcon Digital Signature Algorithm)</strong><br />
            FALCONは、NIST標準化された耐量子暗号アルゴリズムです。<br />
            デジタル署名アルゴリズムとして、コンパクトな署名サイズを実現します。<br />
            <span style="font-size: 0.9em; color: #e8f4f8; font-style: italic;">
              ※ この実装はWebAssemblyでコンパイルされたRust実装（falcon-rust）を使用しています。FALCON-512を実装しています。
            </span>
          </div>

          <!-- 初期化 -->
          <div class="subsection">
            <h3>1. 初期化</h3>
            <button @click="initFalcon()" :disabled="falconState.initialized">WebAssemblyモジュールを初期化</button>
            <div x-show="falconState.initialized" class="output">✅ 初期化完了</div>
            <div x-show="falconState.showDetails.initialization && falconState.initialized" class="detail-section">
              <div class="data-box">
                <div class="data-box-header">初期化完了</div>
                <div class="data-box-content">
                  FALCONが使用可能になりました。鍵ペア生成、署名、検証の各操作を実行できます。
                </div>
              </div>
            </div>
          </div>

          <!-- 鍵ペア生成 -->
          <div class="subsection">
            <h3>
              <button class="detail-toggle"
                @click="falconState.showDetails.keyGeneration = !falconState.showDetails.keyGeneration"
                x-show="falconState.publicKey">
                <span x-show="!falconState.showDetails.keyGeneration">詳細を表示</span>
                <span x-show="falconState.showDetails.keyGeneration">詳細を隠す</span>
              </button>
              2. 鍵ペアの生成
            </h3>
            <button @click="generateFalconKeyPair()" :disabled="!falconState.initialized">鍵ペアを生成</button>
            <div x-show="falconState.publicKey" class="output">
              <div><strong>公開鍵:</strong> <span x-text="formatBytes(falconState.publicKey)"></span></div>
              <div><strong>公開鍵サイズ:</strong> <span x-text="falconState.publicKey?.length"></span> バイト</div>
              <div style="margin-top: 10px;"><strong>秘密鍵:</strong> <span
                  x-text="formatBytes(falconState.privateKey)"></span></div>
              <div><strong>秘密鍵サイズ:</strong> <span x-text="falconState.privateKey?.length"></span> バイト</div>
            </div>
            <div x-show="falconState.showDetails.keyGeneration && falconState.publicKey" class="detail-section">
              <h4>🔍 鍵ペア生成の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 暗号学的に安全な乱数生成器を初期化</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    OsRng（オペレーティングシステムの乱数生成器）を使用<br />
                    CSPRNG（暗号学的擬似乱数生成器）として機能
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. 32バイトのシードを生成</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    乱数生成器から32バイトのシードを生成<br />
                    このシードが鍵生成の基礎となる
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. FALCON-512のkeygenアルゴリズムを実行</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    FALCON.KeyGen()を実行<br />
                    NTRU格子ベースの鍵生成（FFTを使用）
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">4. 公開鍵（PublicKey）を生成</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    NTRU格子の公開パラメータhを生成<br />
                    サイズ: <span x-text="falconState.publicKey?.length || 0"></span> バイト（約897バイト）
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">5. 秘密鍵（SecretKey）を生成</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    秘密多項式f、g、F、Gを保存<br />
                    サイズ: <span x-text="falconState.privateKey?.length || 0"></span> バイト（約1281バイト）
                  </div>
                </div>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. FALCON（Fast-Fourier Lattice-based Compact Signatures over NTRU）は、NTRU格子ベースのデジタル署名方式です。<br />
                2. 鍵生成では、乱数生成器を使用してNTRU格子の秘密多項式f、g、F、Gを生成します。<br />
                3. 公開鍵は、NTRU格子の公開パラメータh = g * f^(-1) mod qから構成されます。FALCON-512では、公開鍵は約897バイトです。<br />
                4. 秘密鍵は、秘密多項式f、g、F、Gを保存します。これにより、署名生成時に正しい署名を生成できます。FALCON-512では、秘密鍵は約1281バイトです。<br />
                5. FALCON-512は、セキュリティレベル1（128ビット）に対応するパラメータセットです。
              </div>
            </div>
          </div>

          <!-- 署名 -->
          <div class="subsection">
            <h3>
              <button class="detail-toggle" @click="falconState.showDetails.signing = !falconState.showDetails.signing"
                x-show="falconState.signature">
                <span x-show="!falconState.showDetails.signing">詳細を表示</span>
                <span x-show="falconState.showDetails.signing">詳細を隠す</span>
              </button>
              3. デジタル署名
            </h3>
            <label>署名するメッセージ:</label>
            <textarea x-model="falconState.message" placeholder="署名するメッセージを入力"
              @input="falconState.error = ''; falconState.signature = null;"></textarea>
            <button @click="signFalcon()" :disabled="!falconState.privateKey || !falconState.message">署名</button>
            <div x-show="falconState.signature" class="output">
              <div><strong>署名:</strong> <span x-text="formatBytes(falconState.signature)"></span></div>
              <div><strong>署名サイズ:</strong> <span x-text="falconState.signature?.length"></span> バイト（約666バイト）</div>
            </div>
            <div x-show="falconState.showDetails.signing && falconState.signature" class="detail-section">
              <h4>🔍 署名の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 入力（文字列）</div>
                  <div class="data-box-content" x-text="falconState.message || '(空)'"></div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. バイト配列に変換</div>
                  <div class="data-box-content" x-text="formatBytesReadable(falconState.messageBytes)"></div>
                  <div class="param-label">長さ: <span x-text="falconState.messageBytes?.length || 0"></span> バイト</div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. メッセージのハッシュ値を計算</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    SHAKE-256を使用してメッセージのハッシュ値を計算
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">4. FFTベースの署名生成</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    高速フーリエ変換（FFT）を使用して署名を生成<br />
                    浮動小数点演算を使用
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">5. 署名をバイト配列にシリアライズ</div>
                  <div class="data-box-content" x-text="formatBytesReadable(falconState.signature?.slice(0, 16) || [])">
                  </div>
                  <div class="param-label">
                    署名サイズ: <span x-text="falconState.signature?.length || 0"></span> バイト
                  </div>
                </div>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. 署名するメッセージをUTF-8エンコーディングでバイト配列に変換します。<br />
                2. SHAKE-256を使用してメッセージのハッシュ値を計算します。<br />
                3. 秘密鍵の秘密多項式f、g、F、Gを使用して、FFTベースの署名アルゴリズムを実行します。<br />
                4. 署名は、NTRU格子の秘密多項式とメッセージのハッシュ値から生成されます。FALCON-512では、署名は約666バイトです。<br />
                5. FALCONの署名は確率的署名であり、同じメッセージでも異なる署名が生成されます。
              </div>
            </div>
          </div>

          <!-- 署名検証 -->
          <div class="subsection">
            <h3>
              <button class="detail-toggle"
                @click="falconState.showDetails.verification = !falconState.showDetails.verification"
                x-show="falconState.verified !== null">
                <span x-show="!falconState.showDetails.verification">詳細を表示</span>
                <span x-show="falconState.showDetails.verification">詳細を隠す</span>
              </button>
              4. 署名検証
            </h3>
            <label>検証するメッセージ:</label>
            <textarea x-model="falconState.verificationMessage" placeholder="検証するメッセージを入力"
              @input="falconState.error = ''; falconState.verified = null;"></textarea>
            <button @click="verifyFalcon()"
              :disabled="!falconState.signature || !falconState.publicKey || !falconState.verificationMessage">検証</button>
            <div x-show="falconState.verified !== null" class="output">
              <div x-show="falconState.verified" style="color: #27ae60; font-weight: bold;">
                ✅ 署名は有効です
              </div>
              <div x-show="!falconState.verified" style="color: #e74c3c; font-weight: bold;">
                ❌ 署名は無効です
              </div>
            </div>
            <div x-show="falconState.showDetails.verification && falconState.verified !== null" class="detail-section">
              <h4>🔍 署名検証の内部処理</h4>
              <div class="data-flow">
                <div class="data-box">
                  <div class="data-box-label">1. 検証するメッセージをバイト配列に変換</div>
                  <div class="data-box-content" x-text="formatBytesReadable(falconState.verificationMessageBytes)">
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">2. メッセージのハッシュ値を計算</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    SHAKE-256を使用してメッセージのハッシュ値を計算
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">3. 署名を復元</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    署名バイト配列から署名オブジェクトを復元
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">4. FFTベースの検証アルゴリズムを実行</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    公開鍵と署名を使用して検証を実行<br />
                    FFTを使用して署名の有効性を確認
                  </div>
                </div>
                <div class="arrow">→</div>
                <div class="data-box">
                  <div class="data-box-label">5. 検証結果を返す</div>
                  <div class="data-box-content" style="font-size: 10px;">
                    <span x-show="falconState.verified">✅ 署名は有効</span>
                    <span x-show="!falconState.verified">❌ 署名は無効</span>
                  </div>
                </div>
              </div>
              <div style="margin-top: 15px; padding: 10px; background: #d5e8f3; border-radius: 4px; font-size: 12px;">
                <strong>処理の説明:</strong><br />
                1. 検証するメッセージをUTF-8エンコーディングでバイト配列に変換します。<br />
                2. SHAKE-256を使用してメッセージのハッシュ値を計算します。<br />
                3. 署名バイト配列から署名オブジェクトを復元します。<br />
                4. 公開鍵と署名を使用して、FFTベースの検証アルゴリズムを実行します。<br />
                5. 署名が有効な場合、検証は成功します。署名が無効な場合（異なるメッセージや公開鍵）、検証は失敗します。
              </div>
            </div>
          </div>

          <div x-show="falconState.error" style="color: #e74c3c; margin-top: 10px;" x-text="falconState.error">
          </div>
        </div>
      </div>
    </template>
  </div>
</body>

</html>